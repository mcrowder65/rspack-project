/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3b/declarations/WebpackOptions.d.ts
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
/// <reference types="node" />
import watchpack from "watchpack";
import webpackDevServer from "webpack-dev-server";
import { Compiler } from "../compiler";
import * as oldBuiltins from "./builtins";
export type { LoaderContext } from "./adapter-rule-use";
export declare type Configuration = RspackOptions;
export interface RspackOptions {
    name?: Name;
    dependencies?: Dependencies;
    context?: Context;
    mode?: Mode;
    entry?: Entry;
    output?: Output;
    resolve?: Resolve;
    module?: ModuleOptions;
    target?: Target;
    externals?: Externals;
    externalsType?: ExternalsType;
    infrastructureLogging?: InfrastructureLogging;
    devtool?: DevTool;
    node?: Node;
    snapshot?: SnapshotOptions;
    cache?: CacheOptions;
    stats?: StatsValue;
    optimization?: Optimization;
    plugins?: Plugins;
    experiments?: Experiments;
    watch?: Watch;
    watchOptions?: WatchOptions;
    devServer?: DevServer;
    builtins?: Builtins;
}
export interface RspackOptionsNormalized {
    name?: Name;
    dependencies?: Dependencies;
    context?: Context;
    mode?: Mode;
    entry: EntryNormalized;
    output: OutputNormalized;
    resolve: Resolve;
    module: ModuleOptionsNormalized;
    target?: Target;
    externals?: Externals;
    externalsType?: ExternalsType;
    infrastructureLogging: InfrastructureLogging;
    devtool?: DevTool;
    node: Node;
    snapshot: SnapshotOptions;
    cache?: CacheOptions;
    stats: StatsValue;
    optimization: Optimization;
    plugins: Plugins;
    experiments: Experiments;
    watch?: Watch;
    watchOptions: WatchOptions;
    devServer?: DevServer;
    builtins: Builtins;
}
export declare type Name = string;
export declare type Dependencies = Name[];
export declare type Context = string;
export declare type Mode = "development" | "production" | "none";
export declare type Entry = EntryStatic;
export declare type EntryStatic = EntryObject | EntryUnnamed;
export declare type EntryUnnamed = EntryItem;
export declare type EntryRuntime = false | string;
export declare type EntryItem = string[] | string;
export interface EntryObject {
    [k: string]: EntryItem | EntryDescription;
}
export interface EntryDescription {
    import: EntryItem;
    runtime?: EntryRuntime;
}
export declare type EntryNormalized = EntryStaticNormalized;
export interface EntryStaticNormalized {
    [k: string]: EntryDescriptionNormalized;
}
export interface EntryDescriptionNormalized {
    import?: string[];
    runtime?: EntryRuntime;
}
export interface Output {
    path?: Path;
    publicPath?: PublicPath;
    filename?: Filename;
    chunkFilename?: ChunkFilename;
    cssFilename?: CssFilename;
    cssChunkFilename?: CssChunkFilename;
    assetModuleFilename?: AssetModuleFilename;
    uniqueName?: UniqueName;
    enabledLibraryTypes?: EnabledLibraryTypes;
    libraryExport?: LibraryExport;
    libraryTarget?: LibraryType;
    auxiliaryComment?: AuxiliaryComment;
    umdNamedDefine?: UmdNamedDefine;
    module?: OutputModule;
    library?: Library;
    strictModuleErrorHandling?: StrictModuleErrorHandling;
    globalObject?: GlobalObject;
    importFunctionName?: ImportFunctionName;
}
export declare type Path = string;
export declare type PublicPath = "auto" | RawPublicPath;
export declare type RawPublicPath = string;
export declare type AssetModuleFilename = string;
export declare type Filename = FilenameTemplate;
export declare type ChunkFilename = FilenameTemplate;
export declare type CssFilename = FilenameTemplate;
export declare type CssChunkFilename = FilenameTemplate;
export declare type FilenameTemplate = string;
export declare type UniqueName = string;
export declare type Library = LibraryName | LibraryOptions;
export declare type StrictModuleErrorHandling = boolean;
export declare type OutputModule = boolean;
export interface LibraryCustomUmdCommentObject {
    amd?: string;
    commonjs?: string;
    commonjs2?: string;
    root?: string;
}
export interface LibraryOptions {
    auxiliaryComment?: AuxiliaryComment;
    export?: LibraryExport;
    name?: LibraryName;
    type: LibraryType;
    umdNamedDefine?: UmdNamedDefine;
}
export declare type LibraryName = string | string[] | LibraryCustomUmdObject;
export interface LibraryCustomUmdObject {
    amd?: string;
    commonjs?: string;
    root?: string | string[];
}
export declare type LibraryExport = string[] | string;
export declare type LibraryType = ("var" | "module" | "assign" | "assign-properties" | "this" | "window" | "self" | "global" | "commonjs" | "commonjs2" | "commonjs-module" | "commonjs-static" | "amd" | "amd-require" | "umd" | "umd2" | "jsonp" | "system") | string;
export declare type AuxiliaryComment = string | LibraryCustomUmdCommentObject;
export declare type UmdNamedDefine = boolean;
export declare type EnabledLibraryTypes = LibraryType[];
export declare type GlobalObject = string;
export declare type ImportFunctionName = string;
export interface OutputNormalized {
    path?: Path;
    publicPath?: PublicPath;
    filename?: Filename;
    chunkFilename?: ChunkFilename;
    cssFilename?: CssFilename;
    cssChunkFilename?: CssChunkFilename;
    assetModuleFilename?: AssetModuleFilename;
    uniqueName?: UniqueName;
    enabledLibraryTypes?: EnabledLibraryTypes;
    library?: LibraryOptions;
    module?: OutputModule;
    strictModuleErrorHandling?: StrictModuleErrorHandling;
    globalObject?: GlobalObject;
    importFunctionName?: ImportFunctionName;
}
export declare type Resolve = ResolveOptions;
export interface ResolveOptions {
    alias?: ResolveAlias;
    /**
     * This is `aliasField: ["browser"]` in webpack, because no one
     * uses aliasField other than "browser". ---@bvanjoi
     */
    browserField?: boolean;
    conditionNames?: string[];
    extensions?: string[];
    fallback?: ResolveAlias;
    mainFields?: string[];
    mainFiles?: string[];
    modules?: string[];
    preferRelative?: boolean;
    tsConfigPath?: string;
}
export declare type ResolveAlias = {
    [k: string]: false | string | Array<string | false>;
};
export interface ModuleOptions {
    defaultRules?: RuleSetRules;
    rules?: RuleSetRules;
    parser?: ParserOptionsByModuleType;
}
export declare type RuleSetRules = ("..." | RuleSetRule)[];
export interface RuleSetRule {
    test?: RuleSetCondition;
    exclude?: RuleSetCondition;
    include?: RuleSetCondition;
    issuer?: RuleSetCondition;
    resource?: RuleSetCondition;
    resourceFragment?: RuleSetCondition;
    resourceQuery?: RuleSetCondition;
    oneOf?: RuleSetRule[];
    type?: string;
    use?: RuleSetUse;
    parser?: {
        [k: string]: any;
    };
    generator?: {
        [k: string]: any;
    };
    resolve?: ResolveOptions;
    sideEffects?: boolean;
}
export declare type RuleSetCondition = RegExp | string | RuleSetConditions | RuleSetLogicalConditions;
export declare type RuleSetConditions = RuleSetCondition[];
export interface RuleSetLogicalConditions {
    and?: RuleSetConditions;
    or?: RuleSetConditions;
    not?: RuleSetCondition;
}
export declare type RuleSetUse = RuleSetUseItem[] | RuleSetUseItem;
export declare type RuleSetUseItem = RuleSetLoaderWithOptions | RuleSetLoader;
export declare type RuleSetLoader = string;
export declare type RuleSetLoaderWithOptions = {
    loader: RuleSetLoader;
    options?: RuleSetLoaderOptions;
};
export declare type RuleSetLoaderOptions = string | {
    [k: string]: any;
};
export declare type ParserOptionsByModuleType = ParserOptionsByModuleTypeKnown;
export interface ParserOptionsByModuleTypeKnown {
    asset?: AssetParserOptions;
}
export interface AssetParserOptions {
    dataUrlCondition?: AssetParserDataUrlOptions;
}
export interface AssetParserDataUrlOptions {
    maxSize?: number;
}
export interface ModuleOptionsNormalized {
    defaultRules?: RuleSetRules;
    rules: RuleSetRules;
    parser: ParserOptionsByModuleType;
}
export declare type Target = false | string[] | string;
export declare type Externals = ExternalItem;
export declare type ExternalItem = string | ExternalItemObjectUnknown;
export interface ExternalItemObjectUnknown {
    [k: string]: ExternalItemValue;
}
export declare type ExternalItemValue = string;
export declare type ExternalsType = "var" | "module" | "assign" | "this" | "window" | "self" | "global" | "commonjs" | "commonjs2" | "commonjs-module" | "commonjs-static" | "amd" | "amd-require" | "umd" | "umd2" | "jsonp" | "system" | "promise" | "import" | "script" | "node-commonjs";
export interface InfrastructureLogging {
    appendOnly?: boolean;
    colors?: boolean;
    console?: Console;
    debug?: boolean | FilterTypes;
    level?: "none" | "error" | "warn" | "info" | "log" | "verbose";
    stream?: NodeJS.WritableStream;
}
export declare type FilterTypes = FilterItemTypes[] | FilterItemTypes;
export declare type FilterItemTypes = RegExp | string | ((value: string) => boolean);
export declare type DevTool = false | "cheap-source-map" | "cheap-module-source-map" | "source-map" | "inline-cheap-source-map" | "inline-cheap-module-source-map" | "inline-source-map" | "inline-nosources-cheap-module-source-map" | "inline-nosources-source-map" | "nosources-cheap-source-map" | "nosources-cheap-module-source-map" | "nosources-source-map" | "hidden-nosources-cheap-source-map" | "hidden-nosources-cheap-module-source-map" | "hidden-nosources-source-map" | "hidden-cheap-source-map" | "hidden-cheap-module-source-map" | "hidden-source-map" | "eval-cheap-source-map" | "eval-cheap-module-source-map" | "eval-source-map" | "eval-nosources-cheap-source-map" | "eval-nosources-cheap-module-source-map" | "eval-nosources-source-map";
export declare type Node = NodeOptions;
export interface NodeOptions {
    __dirname?: false | true | "warn-mock" | "mock" | "eval-only";
    global?: boolean | "warn";
}
export interface SnapshotOptions {
    module?: {
        hash?: boolean;
        timestamp?: boolean;
    };
    resolve?: {
        hash?: boolean;
        timestamp?: boolean;
    };
}
export declare type CacheOptions = true | false;
export declare type StatsValue = ("none" | "errors-only" | "errors-warnings" | "normal" | "verbose") | boolean | StatsOptions;
export interface StatsOptions {
    all?: boolean;
    preset?: "normal" | "none" | "verbose" | "errors-only" | "errors-warnings";
    assets?: boolean;
    chunks?: boolean;
    modules?: boolean;
    entrypoints?: boolean;
    chunkGroups?: boolean;
    warnings?: boolean;
    warningsCount?: boolean;
    errors?: boolean;
    errorsCount?: boolean;
    colors?: boolean;
    hash?: boolean;
    reasons?: boolean;
    publicPath?: boolean;
}
export interface Optimization {
    moduleIds?: "named" | "deterministic";
    minimize?: boolean;
    minimizer?: ("..." | RspackPluginInstance)[];
    splitChunks?: OptimizationSplitChunksOptions | false;
    runtimeChunk?: OptimizationRuntimeChunk;
    removeAvailableModules?: boolean;
    sideEffects?: "flag" | boolean;
}
export interface OptimizationSplitChunksOptions {
    cacheGroups?: {
        [k: string]: OptimizationSplitChunksCacheGroup;
    };
    chunks?: "initial" | "async" | "all";
    maxAsyncRequests?: number;
    maxInitialRequests?: number;
    minChunks?: number;
    minSize?: OptimizationSplitChunksSizes;
    enforceSizeThreshold?: OptimizationSplitChunksSizes;
    minRemainingSize?: OptimizationSplitChunksSizes;
}
export interface OptimizationSplitChunksCacheGroup {
    chunks?: "initial" | "async" | "all";
    minChunks?: number;
    name?: string;
    priority?: number;
    reuseExistingChunk?: boolean;
    test?: RegExp;
}
export declare type OptimizationSplitChunksSizes = number;
export declare type OptimizationRuntimeChunk = ("single" | "multiple") | boolean | {
    name?: string | Function;
};
export declare type OptimizationRuntimeChunkNormalized = false | {
    name: Function;
};
export declare type Plugins = (RspackPluginInstance | RspackPluginFunction)[];
export interface RspackPluginInstance {
    apply: (compiler: Compiler) => void;
    [k: string]: any;
}
export declare type RspackPluginFunction = (this: Compiler, compiler: Compiler) => void;
export interface Experiments {
    lazyCompilation?: boolean;
    incrementalRebuild?: boolean;
}
export declare type Watch = boolean;
export declare type WatchOptions = watchpack.WatchOptions;
export interface DevServer extends webpackDevServer.Configuration {
    hot?: boolean;
}
export declare type Builtins = oldBuiltins.Builtins;
//# sourceMappingURL=types.d.ts.map