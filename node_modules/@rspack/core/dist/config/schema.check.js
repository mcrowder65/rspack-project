/** This file was automatically generated, Run `pnpm precompile-schema` to update */
"use strict";
module.exports = $, module.exports.default = $;
const e = new RegExp("^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$", "u");
function t(e, { instancePath: a = "", parentData: s, parentDataProperty: n, rootData: r = e } = {}) { let i = null, o = 0; if (0 === o) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return t.errors = [{ instancePath: a, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    {
        let s;
        if (void 0 === e.import && (s = "import"))
            return t.errors = [{ instancePath: a, schemaPath: "#/required", keyword: "required", params: { missingProperty: s }, message: "must have required property '" + s + "'" }], !1;
        if (void 0 !== e.import) {
            let s = e.import;
            const n = o, r = o;
            let c = !1;
            const h = o;
            if (o === h)
                if (Array.isArray(s))
                    if (s.length < 1) {
                        const e = { instancePath: a + "/import", schemaPath: "#/definitions/EntryItem/anyOf/0/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                        null === i ? i = [e] : i.push(e), o++;
                    }
                    else {
                        var l = !0;
                        const e = s.length;
                        for (let t = 0; t < e; t++) {
                            let e = s[t];
                            const n = o;
                            if (o === n)
                                if ("string" == typeof e) {
                                    if (e.length < 1) {
                                        const e = { instancePath: a + "/import/" + t, schemaPath: "#/definitions/EntryItem/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                        null === i ? i = [e] : i.push(e), o++;
                                    }
                                }
                                else {
                                    const e = { instancePath: a + "/import/" + t, schemaPath: "#/definitions/EntryItem/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    null === i ? i = [e] : i.push(e), o++;
                                }
                            if (!(l = n === o))
                                break;
                        }
                        if (l) {
                            let e, t = s.length;
                            if (t > 1) {
                                const n = {};
                                for (; t--;) {
                                    let r = s[t];
                                    if ("string" == typeof r) {
                                        if ("number" == typeof n[r]) {
                                            e = n[r];
                                            const s = { instancePath: a + "/import", schemaPath: "#/definitions/EntryItem/anyOf/0/uniqueItems", keyword: "uniqueItems", params: { i: t, j: e }, message: "must NOT have duplicate items (items ## " + e + " and " + t + " are identical)" };
                                            null === i ? i = [s] : i.push(s), o++;
                                            break;
                                        }
                                        n[r] = t;
                                    }
                                }
                            }
                        }
                    }
                else {
                    const e = { instancePath: a + "/import", schemaPath: "#/definitions/EntryItem/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                    null === i ? i = [e] : i.push(e), o++;
                }
            var m = h === o;
            if (c = c || m, !c) {
                const e = o;
                if (o === e)
                    if ("string" == typeof s) {
                        if (s.length < 1) {
                            const e = { instancePath: a + "/import", schemaPath: "#/definitions/EntryItem/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                            null === i ? i = [e] : i.push(e), o++;
                        }
                    }
                    else {
                        const e = { instancePath: a + "/import", schemaPath: "#/definitions/EntryItem/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        null === i ? i = [e] : i.push(e), o++;
                    }
                m = e === o, c = c || m;
            }
            if (!c) {
                const e = { instancePath: a + "/import", schemaPath: "#/definitions/EntryItem/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                return null === i ? i = [e] : i.push(e), o++, t.errors = i, !1;
            }
            o = r, null !== i && (r ? i.length = r : i = null);
            var p = n === o;
        }
        else
            p = !0;
        if (p)
            if (void 0 !== e.runtime) {
                let s = e.runtime;
                const n = o, r = o;
                let l = !1;
                const m = o;
                if (!1 !== s) {
                    const e = { instancePath: a + "/runtime", schemaPath: "#/definitions/EntryRuntime/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                    null === i ? i = [e] : i.push(e), o++;
                }
                var c = m === o;
                if (l = l || c, !l) {
                    const e = o;
                    if (o === e)
                        if ("string" == typeof s) {
                            if (s.length < 1) {
                                const e = { instancePath: a + "/runtime", schemaPath: "#/definitions/EntryRuntime/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                null === i ? i = [e] : i.push(e), o++;
                            }
                        }
                        else {
                            const e = { instancePath: a + "/runtime", schemaPath: "#/definitions/EntryRuntime/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            null === i ? i = [e] : i.push(e), o++;
                        }
                    c = e === o, l = l || c;
                }
                if (!l) {
                    const e = { instancePath: a + "/runtime", schemaPath: "#/definitions/EntryRuntime/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    return null === i ? i = [e] : i.push(e), o++, t.errors = i, !1;
                }
                o = r, null !== i && (r ? i.length = r : i = null), p = n === o;
            }
            else
                p = !0;
    }
} return t.errors = i, 0 === o; }
function a(e, { instancePath: s = "", parentData: n, parentDataProperty: r, rootData: i = e } = {}) { let o = null, l = 0; if (0 === l) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return a.errors = [{ instancePath: s, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    for (const n in e) {
        let r = e[n];
        const h = l, u = l;
        let y = !1;
        const f = l, d = l;
        let g = !1;
        const P = l;
        if (l === P)
            if (Array.isArray(r))
                if (r.length < 1) {
                    const e = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/EntryItem/anyOf/0/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                    null === o ? o = [e] : o.push(e), l++;
                }
                else {
                    var m = !0;
                    const e = r.length;
                    for (let t = 0; t < e; t++) {
                        let e = r[t];
                        const a = l;
                        if (l === a)
                            if ("string" == typeof e) {
                                if (e.length < 1) {
                                    const e = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + t, schemaPath: "#/definitions/EntryItem/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                    null === o ? o = [e] : o.push(e), l++;
                                }
                            }
                            else {
                                const e = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + t, schemaPath: "#/definitions/EntryItem/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                null === o ? o = [e] : o.push(e), l++;
                            }
                        if (!(m = a === l))
                            break;
                    }
                    if (m) {
                        let e, t = r.length;
                        if (t > 1) {
                            const a = {};
                            for (; t--;) {
                                let i = r[t];
                                if ("string" == typeof i) {
                                    if ("number" == typeof a[i]) {
                                        e = a[i];
                                        const r = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/EntryItem/anyOf/0/uniqueItems", keyword: "uniqueItems", params: { i: t, j: e }, message: "must NOT have duplicate items (items ## " + e + " and " + t + " are identical)" };
                                        null === o ? o = [r] : o.push(r), l++;
                                        break;
                                    }
                                    a[i] = t;
                                }
                            }
                        }
                    }
                }
            else {
                const e = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/EntryItem/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                null === o ? o = [e] : o.push(e), l++;
            }
        var p = P === l;
        if (g = g || p, !g) {
            const e = l;
            if (l === e)
                if ("string" == typeof r) {
                    if (r.length < 1) {
                        const e = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/EntryItem/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                        null === o ? o = [e] : o.push(e), l++;
                    }
                }
                else {
                    const e = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/EntryItem/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    null === o ? o = [e] : o.push(e), l++;
                }
            p = e === l, g = g || p;
        }
        if (g)
            l = d, null !== o && (d ? o.length = d : o = null);
        else {
            const e = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/EntryItem/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
            null === o ? o = [e] : o.push(e), l++;
        }
        var c = f === l;
        if (y = y || c, !y) {
            const a = l;
            t(r, { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: e, parentDataProperty: n, rootData: i }) || (o = null === o ? t.errors : o.concat(t.errors), l = o.length), c = a === l, y = y || c;
        }
        if (!y) {
            const e = { instancePath: s + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
            return null === o ? o = [e] : o.push(e), l++, a.errors = o, !1;
        }
        if (l = u, null !== o && (u ? o.length = u : o = null), h !== l)
            break;
    }
} return a.errors = o, 0 === l; }
function s(e, { instancePath: t = "", parentData: a, parentDataProperty: n, rootData: r = e } = {}) { let i = null, o = 0; const l = o; let m = !1, p = null; const c = o, h = o; let u = !1; const y = o; if (o === y)
    if (Array.isArray(e))
        if (e.length < 1) {
            const e = { instancePath: t, schemaPath: "#/definitions/EntryItem/anyOf/0/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
            null === i ? i = [e] : i.push(e), o++;
        }
        else {
            var f = !0;
            const a = e.length;
            for (let s = 0; s < a; s++) {
                let a = e[s];
                const n = o;
                if (o === n)
                    if ("string" == typeof a) {
                        if (a.length < 1) {
                            const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/EntryItem/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                            null === i ? i = [e] : i.push(e), o++;
                        }
                    }
                    else {
                        const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/EntryItem/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        null === i ? i = [e] : i.push(e), o++;
                    }
                if (!(f = n === o))
                    break;
            }
            if (f) {
                let a, s = e.length;
                if (s > 1) {
                    const n = {};
                    for (; s--;) {
                        let r = e[s];
                        if ("string" == typeof r) {
                            if ("number" == typeof n[r]) {
                                a = n[r];
                                const e = { instancePath: t, schemaPath: "#/definitions/EntryItem/anyOf/0/uniqueItems", keyword: "uniqueItems", params: { i: s, j: a }, message: "must NOT have duplicate items (items ## " + a + " and " + s + " are identical)" };
                                null === i ? i = [e] : i.push(e), o++;
                                break;
                            }
                            n[r] = s;
                        }
                    }
                }
            }
        }
    else {
        const e = { instancePath: t, schemaPath: "#/definitions/EntryItem/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
        null === i ? i = [e] : i.push(e), o++;
    } var d = y === o; if (u = u || d, !u) {
    const a = o;
    if (o === a)
        if ("string" == typeof e) {
            if (e.length < 1) {
                const e = { instancePath: t, schemaPath: "#/definitions/EntryItem/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                null === i ? i = [e] : i.push(e), o++;
            }
        }
        else {
            const e = { instancePath: t, schemaPath: "#/definitions/EntryItem/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            null === i ? i = [e] : i.push(e), o++;
        }
    d = a === o, u = u || d;
} if (u)
    o = h, null !== i && (h ? i.length = h : i = null);
else {
    const e = { instancePath: t, schemaPath: "#/definitions/EntryItem/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    null === i ? i = [e] : i.push(e), o++;
} if (c === o && (m = !0, p = 0), !m) {
    const e = { instancePath: t, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: p }, message: "must match exactly one schema in oneOf" };
    return null === i ? i = [e] : i.push(e), o++, s.errors = i, !1;
} return o = l, null !== i && (l ? i.length = l : i = null), s.errors = i, 0 === o; }
function n(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: o = e } = {}) { let l = null, m = 0; const p = m; let c = !1; const h = m; a(e, { instancePath: t, parentData: r, parentDataProperty: i, rootData: o }) || (l = null === l ? a.errors : l.concat(a.errors), m = l.length); var u = h === m; if (c = c || u, !c) {
    const a = m;
    s(e, { instancePath: t, parentData: r, parentDataProperty: i, rootData: o }) || (l = null === l ? s.errors : l.concat(s.errors), m = l.length), u = a === m, c = c || u;
} if (!c) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === l ? l = [e] : l.push(e), m++, n.errors = l, !1;
} return m = p, null !== l && (p ? l.length = p : l = null), n.errors = l, 0 === m; }
function r(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: i = e } = {}) { let o = null, l = 0; const m = l; let p = !1; const c = l; if (n(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: i }) || (o = null === o ? n.errors : o.concat(n.errors), l = o.length), p = p || c === l, !p) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === o ? o = [e] : o.push(e), l++, r.errors = o, !1;
} return l = m, null !== o && (m ? o.length = m : o = null), r.errors = o, 0 === l; }
function i(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, o = 0; const l = o; let m = !1; const p = o; if ("string" != typeof e) {
    const e = { instancePath: t, schemaPath: "#/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
    null === r ? r = [e] : r.push(e), o++;
} var c = p === o; if (m = m || c, !m) {
    const a = o;
    if (o === a)
        if (e && "object" == typeof e && !Array.isArray(e))
            for (const a in e) {
                const s = o, n = o;
                let i = !1;
                const l = o;
                if ("string" != typeof e[a]) {
                    const e = { instancePath: t + "/" + a.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ExternalItemValue/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    null === r ? r = [e] : r.push(e), o++;
                }
                if (i = i || l === o, i)
                    o = n, null !== r && (n ? r.length = n : r = null);
                else {
                    const e = { instancePath: t + "/" + a.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ExternalItemValue/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    null === r ? r = [e] : r.push(e), o++;
                }
                if (s !== o)
                    break;
            }
        else {
            const e = { instancePath: t, schemaPath: "#/anyOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            null === r ? r = [e] : r.push(e), o++;
        }
    c = a === o, m = m || c;
} if (!m) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), o++, i.errors = r, !1;
} return o = l, null !== r && (l ? r.length = l : r = null), i.errors = r, 0 === o; }
function o(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, l = 0; const m = l; let p = !1; const c = l; if (i(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? i.errors : r.concat(i.errors), l = r.length), p = p || c === l, !p) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), l++, o.errors = r, !1;
} return l = m, null !== r && (m ? r.length = m : r = null), o.errors = r, 0 === l; }
function l(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let m = !1; const p = i; if (i === p)
    if (Array.isArray(e)) {
        const a = e.length;
        for (let s = 0; s < a; s++) {
            let a = e[s];
            const n = i, o = i;
            let l = !1, m = null;
            const p = i, h = i;
            let u = !1;
            const y = i;
            if (!(a instanceof RegExp)) {
                const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/FilterItemTypes/anyOf/0/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                null === r ? r = [e] : r.push(e), i++;
            }
            var c = y === i;
            if (u = u || c, !u) {
                const e = i;
                if ("string" != typeof a) {
                    const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/FilterItemTypes/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    null === r ? r = [e] : r.push(e), i++;
                }
                if (c = e === i, u = u || c, !u) {
                    const e = i;
                    if (!(a instanceof Function)) {
                        const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/FilterItemTypes/anyOf/2/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                    c = e === i, u = u || c;
                }
            }
            if (u)
                i = h, null !== r && (h ? r.length = h : r = null);
            else {
                const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/FilterItemTypes/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                null === r ? r = [e] : r.push(e), i++;
            }
            if (p === i && (l = !0, m = 0), l)
                i = o, null !== r && (o ? r.length = o : r = null);
            else {
                const e = { instancePath: t + "/" + s, schemaPath: "#/anyOf/0/items/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                null === r ? r = [e] : r.push(e), i++;
            }
            if (n !== i)
                break;
        }
    }
    else {
        const e = { instancePath: t, schemaPath: "#/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
        null === r ? r = [e] : r.push(e), i++;
    } var h = p === i; if (m = m || h, !m) {
    const a = i, s = i;
    let n = !1;
    const o = i;
    if (!(e instanceof RegExp)) {
        const e = { instancePath: t, schemaPath: "#/definitions/FilterItemTypes/anyOf/0/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
        null === r ? r = [e] : r.push(e), i++;
    }
    var u = o === i;
    if (n = n || u, !n) {
        const a = i;
        if ("string" != typeof e) {
            const e = { instancePath: t, schemaPath: "#/definitions/FilterItemTypes/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            null === r ? r = [e] : r.push(e), i++;
        }
        if (u = a === i, n = n || u, !n) {
            const a = i;
            if (!(e instanceof Function)) {
                const e = { instancePath: t, schemaPath: "#/definitions/FilterItemTypes/anyOf/2/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                null === r ? r = [e] : r.push(e), i++;
            }
            u = a === i, n = n || u;
        }
    }
    if (n)
        i = s, null !== r && (s ? r.length = s : r = null);
    else {
        const e = { instancePath: t, schemaPath: "#/definitions/FilterItemTypes/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
        null === r ? r = [e] : r.push(e), i++;
    }
    h = a === i, m = m || h;
} if (!m) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, l.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), l.errors = r, 0 === i; }
function m(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return m.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    {
        const a = i;
        for (const a in e)
            if ("appendOnly" !== a && "colors" !== a && "console" !== a && "debug" !== a && "level" !== a && "stream" !== a)
                return m.errors = [{ instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" }], !1;
        if (a === i) {
            if (void 0 !== e.appendOnly) {
                const a = i;
                if ("boolean" != typeof e.appendOnly)
                    return m.errors = [{ instancePath: t + "/appendOnly", schemaPath: "#/properties/appendOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                var o = a === i;
            }
            else
                o = !0;
            if (o) {
                if (void 0 !== e.colors) {
                    const a = i;
                    if ("boolean" != typeof e.colors)
                        return m.errors = [{ instancePath: t + "/colors", schemaPath: "#/properties/colors/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                    o = a === i;
                }
                else
                    o = !0;
                if (o) {
                    if (void 0 !== e.debug) {
                        let a = e.debug;
                        const s = i, c = i;
                        let h = !1;
                        const u = i;
                        if ("boolean" != typeof a) {
                            const e = { instancePath: t + "/debug", schemaPath: "#/properties/debug/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                        var p = u === i;
                        if (h = h || p, !h) {
                            const s = i;
                            l(a, { instancePath: t + "/debug", parentData: e, parentDataProperty: "debug", rootData: n }) || (r = null === r ? l.errors : r.concat(l.errors), i = r.length), p = s === i, h = h || p;
                        }
                        if (!h) {
                            const e = { instancePath: t + "/debug", schemaPath: "#/properties/debug/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                            return null === r ? r = [e] : r.push(e), i++, m.errors = r, !1;
                        }
                        i = c, null !== r && (c ? r.length = c : r = null), o = s === i;
                    }
                    else
                        o = !0;
                    if (o)
                        if (void 0 !== e.level) {
                            let a = e.level;
                            const s = i;
                            if ("none" !== a && "error" !== a && "warn" !== a && "info" !== a && "log" !== a && "verbose" !== a)
                                return m.errors = [{ instancePath: t + "/level", schemaPath: "#/properties/level/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' }], !1;
                            o = s === i;
                        }
                        else
                            o = !0;
                }
            }
        }
    }
} return m.errors = r, 0 === i; }
const p = { exclude: { description: "Shortcut for resource.exclude.", oneOf: [{ $ref: "#/definitions/RuleSetConditionOrConditions" }] }, generator: { description: "The options for the module generator.", type: "object" }, include: { description: "Shortcut for resource.include.", oneOf: [{ $ref: "#/definitions/RuleSetConditionOrConditions" }] }, issuer: { description: "Match the issuer of the module (The module pointing to this module).", oneOf: [{ $ref: "#/definitions/RuleSetConditionOrConditions" }] }, oneOf: { description: "Only execute the first matching rule in this array.", type: "array", items: { description: "A rule.", oneOf: [{ $ref: "#/definitions/RuleSetRule" }] } }, parser: { description: "Options for parsing.", type: "object", additionalProperties: !0 }, resolve: { description: "Options for the resolver.", type: "object", oneOf: [{ $ref: "#/definitions/ResolveOptions" }] }, resource: { description: "Match the resource path of the module.", oneOf: [{ $ref: "#/definitions/RuleSetConditionOrConditions" }] }, resourceFragment: { description: "Match the resource fragment of the module.", oneOf: [{ $ref: "#/definitions/RuleSetConditionOrConditions" }] }, resourceQuery: { description: "Match the resource query of the module.", oneOf: [{ $ref: "#/definitions/RuleSetConditionOrConditions" }] }, rules: { description: "Match and execute these rules when this rule is matched.", type: "array", items: { description: "A rule.", oneOf: [{ $ref: "#/definitions/RuleSetRule" }] } }, sideEffects: { description: "Flags a module as with or without side effects.", type: "boolean" }, test: { description: "Shortcut for resource.test.", oneOf: [{ $ref: "#/definitions/RuleSetConditionOrConditions" }] }, type: { description: "Module type to use for the module.", type: "string" }, use: { description: "Modifiers applied to the module when rule is matched.", oneOf: [{ $ref: "#/definitions/RuleSetUse" }] } }, c = Object.prototype.hasOwnProperty, h = { validate: f };
function u(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!Array.isArray(e))
        return u.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
    {
        const a = e.length;
        for (let s = 0; s < a; s++) {
            const a = i, o = i;
            let l = !1, m = null;
            const p = i;
            if (h.validate(e[s], { instancePath: t + "/" + s, parentData: e, parentDataProperty: s, rootData: n }) || (r = null === r ? h.validate.errors : r.concat(h.validate.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                const e = { instancePath: t + "/" + s, schemaPath: "#/items/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                return null === r ? r = [e] : r.push(e), i++, u.errors = r, !1;
            }
            if (i = o, null !== r && (o ? r.length = o : r = null), a !== i)
                break;
        }
    }
} return u.errors = r, 0 === i; }
function y(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return y.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    {
        const a = i;
        for (const a in e)
            if ("and" !== a && "not" !== a && "or" !== a)
                return y.errors = [{ instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" }], !1;
        if (a === i) {
            if (void 0 !== e.and) {
                const a = i, s = i;
                let l = !1, m = null;
                const p = i;
                if (u(e.and, { instancePath: t + "/and", parentData: e, parentDataProperty: "and", rootData: n }) || (r = null === r ? u.errors : r.concat(u.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                    const e = { instancePath: t + "/and", schemaPath: "#/properties/and/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                    return null === r ? r = [e] : r.push(e), i++, y.errors = r, !1;
                }
                i = s, null !== r && (s ? r.length = s : r = null);
                var o = a === i;
            }
            else
                o = !0;
            if (o) {
                if (void 0 !== e.not) {
                    const a = i, s = i;
                    let l = !1, m = null;
                    const p = i;
                    if (h.validate(e.not, { instancePath: t + "/not", parentData: e, parentDataProperty: "not", rootData: n }) || (r = null === r ? h.validate.errors : r.concat(h.validate.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                        const e = { instancePath: t + "/not", schemaPath: "#/properties/not/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                        return null === r ? r = [e] : r.push(e), i++, y.errors = r, !1;
                    }
                    i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                }
                else
                    o = !0;
                if (o)
                    if (void 0 !== e.or) {
                        const a = i, s = i;
                        let l = !1, m = null;
                        const p = i;
                        if (u(e.or, { instancePath: t + "/or", parentData: e, parentDataProperty: "or", rootData: n }) || (r = null === r ? u.errors : r.concat(u.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                            const e = { instancePath: t + "/or", schemaPath: "#/properties/or/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                            return null === r ? r = [e] : r.push(e), i++, y.errors = r, !1;
                        }
                        i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                    }
                    else
                        o = !0;
            }
        }
    }
} return y.errors = r, 0 === i; }
function f(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; if (!(e instanceof RegExp)) {
    const e = { instancePath: t, schemaPath: "#/anyOf/0/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
    null === r ? r = [e] : r.push(e), i++;
} var p = m === i; if (l = l || p, !l) {
    const o = i;
    if ("string" != typeof e) {
        const e = { instancePath: t, schemaPath: "#/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        null === r ? r = [e] : r.push(e), i++;
    }
    if (p = o === i, l = l || p, !l) {
        const o = i;
        if (y(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? y.errors : r.concat(y.errors), i = r.length), p = o === i, l = l || p, !l) {
            const o = i;
            u(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? u.errors : r.concat(u.errors), i = r.length), p = o === i, l = l || p;
        }
    }
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, f.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), f.errors = r, 0 === i; }
function d(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; f(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? f.errors : r.concat(f.errors), i = r.length); var p = m === i; if (l = l || p, !l) {
    const o = i;
    u(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? u.errors : r.concat(u.errors), i = r.length), p = o === i, l = l || p;
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, d.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), d.errors = r, 0 === i; }
function g(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return g.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    if (void 0 !== e.alias) {
        let a = e.alias;
        const s = i, n = i;
        let m = !1;
        const p = i;
        if (i === p)
            if (a && "object" == typeof a && !Array.isArray(a))
                for (const e in a) {
                    let s = a[e];
                    const n = i, l = i;
                    let m = !1;
                    const p = i;
                    if (i === p)
                        if (Array.isArray(s)) {
                            const a = s.length;
                            for (let n = 0; n < a; n++) {
                                let a = s[n];
                                const o = i;
                                if (i === o)
                                    if ("string" == typeof a) {
                                        if (a.length < 1) {
                                            const a = { instancePath: t + "/alias/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + n, schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                            null === r ? r = [a] : r.push(a), i++;
                                        }
                                    }
                                    else {
                                        const a = { instancePath: t + "/alias/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + n, schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                        null === r ? r = [a] : r.push(a), i++;
                                    }
                                if (o !== i)
                                    break;
                            }
                        }
                        else {
                            const a = { instancePath: t + "/alias/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                            null === r ? r = [a] : r.push(a), i++;
                        }
                    var o = p === i;
                    if (m = m || o, !m) {
                        const a = i;
                        if (!1 !== s) {
                            const a = { instancePath: t + "/alias/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/1/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                            null === r ? r = [a] : r.push(a), i++;
                        }
                        if (o = a === i, m = m || o, !m) {
                            const a = i;
                            if (i === a)
                                if ("string" == typeof s) {
                                    if (s.length < 1) {
                                        const a = { instancePath: t + "/alias/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/2/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                        null === r ? r = [a] : r.push(a), i++;
                                    }
                                }
                                else {
                                    const a = { instancePath: t + "/alias/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/2/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    null === r ? r = [a] : r.push(a), i++;
                                }
                            o = a === i, m = m || o;
                        }
                    }
                    if (m)
                        i = l, null !== r && (l ? r.length = l : r = null);
                    else {
                        const a = { instancePath: t + "/alias/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                        null === r ? r = [a] : r.push(a), i++;
                    }
                    if (n !== i)
                        break;
                }
            else {
                const e = { instancePath: t + "/alias", schemaPath: "#/definitions/ResolveAlias/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                null === r ? r = [e] : r.push(e), i++;
            }
        if (m = m || p === i, !m) {
            const e = { instancePath: t + "/alias", schemaPath: "#/definitions/ResolveAlias/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
            return null === r ? r = [e] : r.push(e), i++, g.errors = r, !1;
        }
        i = n, null !== r && (n ? r.length = n : r = null);
        var l = s === i;
    }
    else
        l = !0;
    if (l) {
        if (void 0 !== e.browserField) {
            const a = i;
            if ("boolean" != typeof e.browserField)
                return g.errors = [{ instancePath: t + "/browserField", schemaPath: "#/properties/browserField/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
            l = a === i;
        }
        else
            l = !0;
        if (l) {
            if (void 0 !== e.conditionNames) {
                let a = e.conditionNames;
                const s = i;
                if (i === s) {
                    if (!Array.isArray(a))
                        return g.errors = [{ instancePath: t + "/conditionNames", schemaPath: "#/properties/conditionNames/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                    {
                        const e = a.length;
                        for (let s = 0; s < e; s++) {
                            const e = i;
                            if ("string" != typeof a[s])
                                return g.errors = [{ instancePath: t + "/conditionNames/" + s, schemaPath: "#/properties/conditionNames/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                            if (e !== i)
                                break;
                        }
                    }
                }
                l = s === i;
            }
            else
                l = !0;
            if (l) {
                if (void 0 !== e.extensions) {
                    let a = e.extensions;
                    const s = i;
                    if (i === s) {
                        if (!Array.isArray(a))
                            return g.errors = [{ instancePath: t + "/extensions", schemaPath: "#/properties/extensions/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                        {
                            const e = a.length;
                            for (let s = 0; s < e; s++) {
                                const e = i;
                                if ("string" != typeof a[s])
                                    return g.errors = [{ instancePath: t + "/extensions/" + s, schemaPath: "#/properties/extensions/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                if (e !== i)
                                    break;
                            }
                        }
                    }
                    l = s === i;
                }
                else
                    l = !0;
                if (l) {
                    if (void 0 !== e.fallback) {
                        let a = e.fallback;
                        const s = i, n = i;
                        let o = !1, p = null;
                        const c = i, h = i;
                        let u = !1;
                        const y = i;
                        if (i === y)
                            if (a && "object" == typeof a && !Array.isArray(a))
                                for (const e in a) {
                                    let s = a[e];
                                    const n = i, o = i;
                                    let l = !1;
                                    const p = i;
                                    if (i === p)
                                        if (Array.isArray(s)) {
                                            const a = s.length;
                                            for (let n = 0; n < a; n++) {
                                                let a = s[n];
                                                const o = i;
                                                if (i === o)
                                                    if ("string" == typeof a) {
                                                        if (a.length < 1) {
                                                            const a = { instancePath: t + "/fallback/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + n, schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                            null === r ? r = [a] : r.push(a), i++;
                                                        }
                                                    }
                                                    else {
                                                        const a = { instancePath: t + "/fallback/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + n, schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                        null === r ? r = [a] : r.push(a), i++;
                                                    }
                                                if (o !== i)
                                                    break;
                                            }
                                        }
                                        else {
                                            const a = { instancePath: t + "/fallback/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                            null === r ? r = [a] : r.push(a), i++;
                                        }
                                    var m = p === i;
                                    if (l = l || m, !l) {
                                        const a = i;
                                        if (!1 !== s) {
                                            const a = { instancePath: t + "/fallback/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/1/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                            null === r ? r = [a] : r.push(a), i++;
                                        }
                                        if (m = a === i, l = l || m, !l) {
                                            const a = i;
                                            if (i === a)
                                                if ("string" == typeof s) {
                                                    if (s.length < 1) {
                                                        const a = { instancePath: t + "/fallback/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/2/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                        null === r ? r = [a] : r.push(a), i++;
                                                    }
                                                }
                                                else {
                                                    const a = { instancePath: t + "/fallback/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf/2/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                    null === r ? r = [a] : r.push(a), i++;
                                                }
                                            m = a === i, l = l || m;
                                        }
                                    }
                                    if (l)
                                        i = o, null !== r && (o ? r.length = o : r = null);
                                    else {
                                        const a = { instancePath: t + "/fallback/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/ResolveAlias/anyOf/0/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                        null === r ? r = [a] : r.push(a), i++;
                                    }
                                    if (n !== i)
                                        break;
                                }
                            else {
                                const e = { instancePath: t + "/fallback", schemaPath: "#/definitions/ResolveAlias/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                                null === r ? r = [e] : r.push(e), i++;
                            }
                        if (u = u || y === i, u)
                            i = h, null !== r && (h ? r.length = h : r = null);
                        else {
                            const e = { instancePath: t + "/fallback", schemaPath: "#/definitions/ResolveAlias/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                        if (c === i && (o = !0, p = 0), !o) {
                            const e = { instancePath: t + "/fallback", schemaPath: "#/properties/fallback/oneOf", keyword: "oneOf", params: { passingSchemas: p }, message: "must match exactly one schema in oneOf" };
                            return null === r ? r = [e] : r.push(e), i++, g.errors = r, !1;
                        }
                        i = n, null !== r && (n ? r.length = n : r = null), l = s === i;
                    }
                    else
                        l = !0;
                    if (l) {
                        if (void 0 !== e.mainFields) {
                            let a = e.mainFields;
                            const s = i;
                            if (i === s) {
                                if (!Array.isArray(a))
                                    return g.errors = [{ instancePath: t + "/mainFields", schemaPath: "#/properties/mainFields/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                {
                                    const e = a.length;
                                    for (let s = 0; s < e; s++) {
                                        let e = a[s];
                                        const n = i, o = i;
                                        let l = !1;
                                        const m = i;
                                        if (i === m)
                                            if (Array.isArray(e)) {
                                                const a = e.length;
                                                for (let n = 0; n < a; n++) {
                                                    let a = e[n];
                                                    const o = i;
                                                    if (i === o)
                                                        if ("string" == typeof a) {
                                                            if (a.length < 1) {
                                                                const e = { instancePath: t + "/mainFields/" + s + "/" + n, schemaPath: "#/properties/mainFields/items/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                                null === r ? r = [e] : r.push(e), i++;
                                                            }
                                                        }
                                                        else {
                                                            const e = { instancePath: t + "/mainFields/" + s + "/" + n, schemaPath: "#/properties/mainFields/items/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                            null === r ? r = [e] : r.push(e), i++;
                                                        }
                                                    if (o !== i)
                                                        break;
                                                }
                                            }
                                            else {
                                                const e = { instancePath: t + "/mainFields/" + s, schemaPath: "#/properties/mainFields/items/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                null === r ? r = [e] : r.push(e), i++;
                                            }
                                        var p = m === i;
                                        if (l = l || p, !l) {
                                            const a = i;
                                            if (i === a)
                                                if ("string" == typeof e) {
                                                    if (e.length < 1) {
                                                        const e = { instancePath: t + "/mainFields/" + s, schemaPath: "#/properties/mainFields/items/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                        null === r ? r = [e] : r.push(e), i++;
                                                    }
                                                }
                                                else {
                                                    const e = { instancePath: t + "/mainFields/" + s, schemaPath: "#/properties/mainFields/items/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                    null === r ? r = [e] : r.push(e), i++;
                                                }
                                            p = a === i, l = l || p;
                                        }
                                        if (!l) {
                                            const e = { instancePath: t + "/mainFields/" + s, schemaPath: "#/properties/mainFields/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            return null === r ? r = [e] : r.push(e), i++, g.errors = r, !1;
                                        }
                                        if (i = o, null !== r && (o ? r.length = o : r = null), n !== i)
                                            break;
                                    }
                                }
                            }
                            l = s === i;
                        }
                        else
                            l = !0;
                        if (l) {
                            if (void 0 !== e.mainFiles) {
                                let a = e.mainFiles;
                                const s = i;
                                if (i === s) {
                                    if (!Array.isArray(a))
                                        return g.errors = [{ instancePath: t + "/mainFiles", schemaPath: "#/properties/mainFiles/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                    {
                                        const e = a.length;
                                        for (let s = 0; s < e; s++) {
                                            let e = a[s];
                                            const n = i;
                                            if (i === n) {
                                                if ("string" != typeof e)
                                                    return g.errors = [{ instancePath: t + "/mainFiles/" + s, schemaPath: "#/properties/mainFiles/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                if (e.length < 1)
                                                    return g.errors = [{ instancePath: t + "/mainFiles/" + s, schemaPath: "#/properties/mainFiles/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' }], !1;
                                            }
                                            if (n !== i)
                                                break;
                                        }
                                    }
                                }
                                l = s === i;
                            }
                            else
                                l = !0;
                            if (l) {
                                if (void 0 !== e.modules) {
                                    let a = e.modules;
                                    const s = i;
                                    if (i === s) {
                                        if (!Array.isArray(a))
                                            return g.errors = [{ instancePath: t + "/modules", schemaPath: "#/properties/modules/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                        {
                                            const e = a.length;
                                            for (let s = 0; s < e; s++) {
                                                let e = a[s];
                                                const n = i;
                                                if (i === n) {
                                                    if ("string" != typeof e)
                                                        return g.errors = [{ instancePath: t + "/modules/" + s, schemaPath: "#/properties/modules/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                    if (e.length < 1)
                                                        return g.errors = [{ instancePath: t + "/modules/" + s, schemaPath: "#/properties/modules/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' }], !1;
                                                }
                                                if (n !== i)
                                                    break;
                                            }
                                        }
                                    }
                                    l = s === i;
                                }
                                else
                                    l = !0;
                                if (l) {
                                    if (void 0 !== e.preferRelative) {
                                        const a = i;
                                        if ("boolean" != typeof e.preferRelative)
                                            return g.errors = [{ instancePath: t + "/preferRelative", schemaPath: "#/properties/preferRelative/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                        l = a === i;
                                    }
                                    else
                                        l = !0;
                                    if (l)
                                        if (void 0 !== e.tsConfigPath) {
                                            const a = i;
                                            if ("string" != typeof e.tsConfigPath)
                                                return g.errors = [{ instancePath: t + "/tsConfigPath", schemaPath: "#/properties/tsConfigPath/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                            l = a === i;
                                        }
                                        else
                                            l = !0;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
} return g.errors = r, 0 === i; }
function P(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; if (i === m)
    if (e && "object" == typeof e && !Array.isArray(e)) {
        const a = i;
        for (const a in e)
            if ("loader" !== a && "options" !== a) {
                const e = { instancePath: t, schemaPath: "#/anyOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" };
                null === r ? r = [e] : r.push(e), i++;
                break;
            }
        if (a === i) {
            if (void 0 !== e.loader) {
                let a = e.loader;
                const s = i, n = i;
                let o = !1, l = null;
                const m = i;
                if (i == i)
                    if ("string" == typeof a) {
                        if (a.length < 1) {
                            const e = { instancePath: t + "/loader", schemaPath: "#/definitions/RuleSetLoader/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                    }
                    else {
                        const e = { instancePath: t + "/loader", schemaPath: "#/definitions/RuleSetLoader/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                if (m === i && (o = !0, l = 0), o)
                    i = n, null !== r && (n ? r.length = n : r = null);
                else {
                    const e = { instancePath: t + "/loader", schemaPath: "#/anyOf/0/properties/loader/oneOf", keyword: "oneOf", params: { passingSchemas: l }, message: "must match exactly one schema in oneOf" };
                    null === r ? r = [e] : r.push(e), i++;
                }
                var p = s === i;
            }
            else
                p = !0;
            if (p)
                if (void 0 !== e.options) {
                    let a = e.options;
                    const s = i, n = i;
                    let o = !1, l = null;
                    const m = i, h = i;
                    let u = !1;
                    const y = i;
                    if ("string" != typeof a) {
                        const e = { instancePath: t + "/options", schemaPath: "#/definitions/RuleSetLoaderOptions/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                    var c = y === i;
                    if (u = u || c, !u) {
                        const e = i;
                        if (!a || "object" != typeof a || Array.isArray(a)) {
                            const e = { instancePath: t + "/options", schemaPath: "#/definitions/RuleSetLoaderOptions/anyOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                        c = e === i, u = u || c;
                    }
                    if (u)
                        i = h, null !== r && (h ? r.length = h : r = null);
                    else {
                        const e = { instancePath: t + "/options", schemaPath: "#/definitions/RuleSetLoaderOptions/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                    if (m === i && (o = !0, l = 0), o)
                        i = n, null !== r && (n ? r.length = n : r = null);
                    else {
                        const e = { instancePath: t + "/options", schemaPath: "#/anyOf/0/properties/options/oneOf", keyword: "oneOf", params: { passingSchemas: l }, message: "must match exactly one schema in oneOf" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                    p = s === i;
                }
                else
                    p = !0;
        }
    }
    else {
        const e = { instancePath: t, schemaPath: "#/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
        null === r ? r = [e] : r.push(e), i++;
    } var h = m === i; if (l = l || h, !l) {
    const a = i;
    if (i == i)
        if ("string" == typeof e) {
            if (e.length < 1) {
                const e = { instancePath: t, schemaPath: "#/definitions/RuleSetLoader/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                null === r ? r = [e] : r.push(e), i++;
            }
        }
        else {
            const e = { instancePath: t, schemaPath: "#/definitions/RuleSetLoader/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            null === r ? r = [e] : r.push(e), i++;
        }
    h = a === i, l = l || h;
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, P.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), P.errors = r, 0 === i; }
function b(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; if (i === m)
    if (Array.isArray(e)) {
        const a = e.length;
        for (let s = 0; s < a; s++) {
            const a = i, o = i;
            let l = !1, m = null;
            const p = i;
            if (P(e[s], { instancePath: t + "/" + s, parentData: e, parentDataProperty: s, rootData: n }) || (r = null === r ? P.errors : r.concat(P.errors), i = r.length), p === i && (l = !0, m = 0), l)
                i = o, null !== r && (o ? r.length = o : r = null);
            else {
                const e = { instancePath: t + "/" + s, schemaPath: "#/anyOf/0/items/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                null === r ? r = [e] : r.push(e), i++;
            }
            if (a !== i)
                break;
        }
    }
    else {
        const e = { instancePath: t, schemaPath: "#/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
        null === r ? r = [e] : r.push(e), i++;
    } var p = m === i; if (l = l || p, !l) {
    const o = i;
    P(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? P.errors : r.concat(P.errors), i = r.length), p = o === i, l = l || p;
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, b.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), b.errors = r, 0 === i; }
const O = { validate: k };
function k(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return k.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    {
        const a = i;
        for (const a in e)
            if (!c.call(p, a))
                return k.errors = [{ instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" }], !1;
        if (a === i) {
            if (void 0 !== e.exclude) {
                const a = i, s = i;
                let l = !1, m = null;
                const p = i;
                if (d(e.exclude, { instancePath: t + "/exclude", parentData: e, parentDataProperty: "exclude", rootData: n }) || (r = null === r ? d.errors : r.concat(d.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                    const e = { instancePath: t + "/exclude", schemaPath: "#/properties/exclude/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                    return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                }
                i = s, null !== r && (s ? r.length = s : r = null);
                var o = a === i;
            }
            else
                o = !0;
            if (o) {
                if (void 0 !== e.generator) {
                    let a = e.generator;
                    const s = i;
                    if (!a || "object" != typeof a || Array.isArray(a))
                        return k.errors = [{ instancePath: t + "/generator", schemaPath: "#/properties/generator/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                    o = s === i;
                }
                else
                    o = !0;
                if (o) {
                    if (void 0 !== e.include) {
                        const a = i, s = i;
                        let l = !1, m = null;
                        const p = i;
                        if (d(e.include, { instancePath: t + "/include", parentData: e, parentDataProperty: "include", rootData: n }) || (r = null === r ? d.errors : r.concat(d.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                            const e = { instancePath: t + "/include", schemaPath: "#/properties/include/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                            return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                        }
                        i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                    }
                    else
                        o = !0;
                    if (o) {
                        if (void 0 !== e.issuer) {
                            const a = i, s = i;
                            let l = !1, m = null;
                            const p = i;
                            if (d(e.issuer, { instancePath: t + "/issuer", parentData: e, parentDataProperty: "issuer", rootData: n }) || (r = null === r ? d.errors : r.concat(d.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                                const e = { instancePath: t + "/issuer", schemaPath: "#/properties/issuer/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                                return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                            }
                            i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                        }
                        else
                            o = !0;
                        if (o) {
                            if (void 0 !== e.oneOf) {
                                let a = e.oneOf;
                                const s = i;
                                if (i === s) {
                                    if (!Array.isArray(a))
                                        return k.errors = [{ instancePath: t + "/oneOf", schemaPath: "#/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                    {
                                        const e = a.length;
                                        for (let s = 0; s < e; s++) {
                                            const e = i, o = i;
                                            let l = !1, m = null;
                                            const p = i;
                                            if (O.validate(a[s], { instancePath: t + "/oneOf/" + s, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? O.validate.errors : r.concat(O.validate.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                                                const e = { instancePath: t + "/oneOf/" + s, schemaPath: "#/properties/oneOf/items/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                                                return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                                            }
                                            if (i = o, null !== r && (o ? r.length = o : r = null), e !== i)
                                                break;
                                        }
                                    }
                                }
                                o = s === i;
                            }
                            else
                                o = !0;
                            if (o) {
                                if (void 0 !== e.parser) {
                                    let a = e.parser;
                                    const s = i;
                                    if (i === s && (!a || "object" != typeof a || Array.isArray(a)))
                                        return k.errors = [{ instancePath: t + "/parser", schemaPath: "#/properties/parser/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                    o = s === i;
                                }
                                else
                                    o = !0;
                                if (o) {
                                    if (void 0 !== e.resolve) {
                                        let a = e.resolve;
                                        const s = i;
                                        if (!a || "object" != typeof a || Array.isArray(a))
                                            return k.errors = [{ instancePath: t + "/resolve", schemaPath: "#/properties/resolve/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                        const l = i;
                                        let m = !1, p = null;
                                        const c = i;
                                        if (g(a, { instancePath: t + "/resolve", parentData: e, parentDataProperty: "resolve", rootData: n }) || (r = null === r ? g.errors : r.concat(g.errors), i = r.length), c === i && (m = !0, p = 0), !m) {
                                            const e = { instancePath: t + "/resolve", schemaPath: "#/properties/resolve/oneOf", keyword: "oneOf", params: { passingSchemas: p }, message: "must match exactly one schema in oneOf" };
                                            return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                                        }
                                        i = l, null !== r && (l ? r.length = l : r = null), o = s === i;
                                    }
                                    else
                                        o = !0;
                                    if (o) {
                                        if (void 0 !== e.resource) {
                                            const a = i, s = i;
                                            let l = !1, m = null;
                                            const p = i;
                                            if (d(e.resource, { instancePath: t + "/resource", parentData: e, parentDataProperty: "resource", rootData: n }) || (r = null === r ? d.errors : r.concat(d.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                                                const e = { instancePath: t + "/resource", schemaPath: "#/properties/resource/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                                                return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                                            }
                                            i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                                        }
                                        else
                                            o = !0;
                                        if (o) {
                                            if (void 0 !== e.resourceFragment) {
                                                const a = i, s = i;
                                                let l = !1, m = null;
                                                const p = i;
                                                if (d(e.resourceFragment, { instancePath: t + "/resourceFragment", parentData: e, parentDataProperty: "resourceFragment", rootData: n }) || (r = null === r ? d.errors : r.concat(d.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                                                    const e = { instancePath: t + "/resourceFragment", schemaPath: "#/properties/resourceFragment/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                                                    return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                                                }
                                                i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                                            }
                                            else
                                                o = !0;
                                            if (o) {
                                                if (void 0 !== e.resourceQuery) {
                                                    const a = i, s = i;
                                                    let l = !1, m = null;
                                                    const p = i;
                                                    if (d(e.resourceQuery, { instancePath: t + "/resourceQuery", parentData: e, parentDataProperty: "resourceQuery", rootData: n }) || (r = null === r ? d.errors : r.concat(d.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                                                        const e = { instancePath: t + "/resourceQuery", schemaPath: "#/properties/resourceQuery/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                                                        return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                                                    }
                                                    i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                                                }
                                                else
                                                    o = !0;
                                                if (o) {
                                                    if (void 0 !== e.rules) {
                                                        let a = e.rules;
                                                        const s = i;
                                                        if (i === s) {
                                                            if (!Array.isArray(a))
                                                                return k.errors = [{ instancePath: t + "/rules", schemaPath: "#/properties/rules/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                                                            {
                                                                const e = a.length;
                                                                for (let s = 0; s < e; s++) {
                                                                    const e = i, o = i;
                                                                    let l = !1, m = null;
                                                                    const p = i;
                                                                    if (O.validate(a[s], { instancePath: t + "/rules/" + s, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? O.validate.errors : r.concat(O.validate.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                                                                        const e = { instancePath: t + "/rules/" + s, schemaPath: "#/properties/rules/items/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                                                                        return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                                                                    }
                                                                    if (i = o, null !== r && (o ? r.length = o : r = null), e !== i)
                                                                        break;
                                                                }
                                                            }
                                                        }
                                                        o = s === i;
                                                    }
                                                    else
                                                        o = !0;
                                                    if (o) {
                                                        if (void 0 !== e.sideEffects) {
                                                            const a = i;
                                                            if ("boolean" != typeof e.sideEffects)
                                                                return k.errors = [{ instancePath: t + "/sideEffects", schemaPath: "#/properties/sideEffects/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                            o = a === i;
                                                        }
                                                        else
                                                            o = !0;
                                                        if (o) {
                                                            if (void 0 !== e.test) {
                                                                const a = i, s = i;
                                                                let l = !1, m = null;
                                                                const p = i;
                                                                if (d(e.test, { instancePath: t + "/test", parentData: e, parentDataProperty: "test", rootData: n }) || (r = null === r ? d.errors : r.concat(d.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                                                                    const e = { instancePath: t + "/test", schemaPath: "#/properties/test/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                                                                    return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                                                                }
                                                                i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                                                            }
                                                            else
                                                                o = !0;
                                                            if (o) {
                                                                if (void 0 !== e.type) {
                                                                    const a = i;
                                                                    if ("string" != typeof e.type)
                                                                        return k.errors = [{ instancePath: t + "/type", schemaPath: "#/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                    o = a === i;
                                                                }
                                                                else
                                                                    o = !0;
                                                                if (o)
                                                                    if (void 0 !== e.use) {
                                                                        const a = i, s = i;
                                                                        let l = !1, m = null;
                                                                        const p = i;
                                                                        if (b(e.use, { instancePath: t + "/use", parentData: e, parentDataProperty: "use", rootData: n }) || (r = null === r ? b.errors : r.concat(b.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                                                                            const e = { instancePath: t + "/use", schemaPath: "#/properties/use/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                                                                            return null === r ? r = [e] : r.push(e), i++, k.errors = r, !1;
                                                                        }
                                                                        i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                                                                    }
                                                                    else
                                                                        o = !0;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
} return k.errors = r, 0 === i; }
function w(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!Array.isArray(e))
        return w.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
    {
        const a = e.length;
        for (let s = 0; s < a; s++) {
            let a = e[s];
            const l = i, m = i;
            let p = !1;
            const c = i;
            if ("..." !== a) {
                const e = { instancePath: t + "/" + s, schemaPath: "#/items/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                null === r ? r = [e] : r.push(e), i++;
            }
            var o = c === i;
            if (p = p || o, !p) {
                const l = i;
                k(a, { instancePath: t + "/" + s, parentData: e, parentDataProperty: s, rootData: n }) || (r = null === r ? k.errors : r.concat(k.errors), i = r.length), o = l === i, p = p || o;
            }
            if (!p) {
                const e = { instancePath: t + "/" + s, schemaPath: "#/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                return null === r ? r = [e] : r.push(e), i++, w.errors = r, !1;
            }
            if (i = m, null !== r && (m ? r.length = m : r = null), l !== i)
                break;
        }
    }
} return w.errors = r, 0 === i; }
function v(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return v.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    {
        const a = i;
        for (const a in e)
            if ("dataUrlCondition" !== a)
                return v.errors = [{ instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" }], !1;
        if (a === i && void 0 !== e.dataUrlCondition) {
            let a = e.dataUrlCondition;
            const s = i;
            let n = !1;
            const o = i;
            if (i == i)
                if (a && "object" == typeof a && !Array.isArray(a)) {
                    const e = i;
                    for (const e in a)
                        if ("maxSize" !== e) {
                            const a = { instancePath: t + "/dataUrlCondition", schemaPath: "#/definitions/AssetParserDataUrlOptions/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: e }, message: "must NOT have additional properties" };
                            null === r ? r = [a] : r.push(a), i++;
                            break;
                        }
                    if (e === i && void 0 !== a.maxSize && "number" != typeof a.maxSize) {
                        const e = { instancePath: t + "/dataUrlCondition/maxSize", schemaPath: "#/definitions/AssetParserDataUrlOptions/properties/maxSize/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                }
                else {
                    const e = { instancePath: t + "/dataUrlCondition", schemaPath: "#/definitions/AssetParserDataUrlOptions/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                    null === r ? r = [e] : r.push(e), i++;
                }
            if (n = n || o === i, !n) {
                const e = { instancePath: t + "/dataUrlCondition", schemaPath: "#/properties/dataUrlCondition/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                return null === r ? r = [e] : r.push(e), i++, v.errors = r, !1;
            }
            i = s, null !== r && (s ? r.length = s : r = null);
        }
    }
} return v.errors = r, 0 === i; }
function D(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return D.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    {
        const a = i;
        for (const a in e)
            if ("asset" !== a) {
                let s = e[a];
                const n = i;
                if (i === n && (!s || "object" != typeof s || Array.isArray(s)))
                    return D.errors = [{ instancePath: t + "/" + a.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                if (n !== i)
                    break;
            }
        a === i && void 0 !== e.asset && (v(e.asset, { instancePath: t + "/asset", parentData: e, parentDataProperty: "asset", rootData: n }) || (r = null === r ? v.errors : r.concat(v.errors), i = r.length));
    }
} return D.errors = r, 0 === i; }
function j(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return j.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    {
        const a = i;
        for (const a in e)
            if ("defaultRules" !== a && "parser" !== a && "rules" !== a)
                return j.errors = [{ instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" }], !1;
        if (a === i) {
            if (void 0 !== e.defaultRules) {
                const a = i, s = i;
                let l = !1, m = null;
                const p = i;
                if (w(e.defaultRules, { instancePath: t + "/defaultRules", parentData: e, parentDataProperty: "defaultRules", rootData: n }) || (r = null === r ? w.errors : r.concat(w.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                    const e = { instancePath: t + "/defaultRules", schemaPath: "#/properties/defaultRules/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                    return null === r ? r = [e] : r.push(e), i++, j.errors = r, !1;
                }
                i = s, null !== r && (s ? r.length = s : r = null);
                var o = a === i;
            }
            else
                o = !0;
            if (o) {
                if (void 0 !== e.parser) {
                    const a = i;
                    D(e.parser, { instancePath: t + "/parser", parentData: e, parentDataProperty: "parser", rootData: n }) || (r = null === r ? D.errors : r.concat(D.errors), i = r.length), o = a === i;
                }
                else
                    o = !0;
                if (o)
                    if (void 0 !== e.rules) {
                        const a = i, s = i;
                        let l = !1, m = null;
                        const p = i;
                        if (w(e.rules, { instancePath: t + "/rules", parentData: e, parentDataProperty: "rules", rootData: n }) || (r = null === r ? w.errors : r.concat(w.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                            const e = { instancePath: t + "/rules", schemaPath: "#/properties/rules/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                            return null === r ? r = [e] : r.push(e), i++, j.errors = r, !1;
                        }
                        i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                    }
                    else
                        o = !0;
            }
        }
    }
} return j.errors = r, 0 === i; }
function A(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; if (!1 !== e) {
    const e = { instancePath: t, schemaPath: "#/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
    null === r ? r = [e] : r.push(e), i++;
} var p = m === i; if (l = l || p, !l) {
    const a = i;
    if (i == i)
        if (e && "object" == typeof e && !Array.isArray(e)) {
            const a = i;
            for (const a in e)
                if ("__dirname" !== a && "global" !== a) {
                    const e = { instancePath: t, schemaPath: "#/definitions/NodeOptions/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" };
                    null === r ? r = [e] : r.push(e), i++;
                    break;
                }
            if (a === i) {
                if (void 0 !== e.__dirname) {
                    let a = e.__dirname;
                    const s = i;
                    if (!1 !== a && !0 !== a && "warn-mock" !== a && "mock" !== a && "eval-only" !== a) {
                        const e = { instancePath: t + "/__dirname", schemaPath: "#/definitions/NodeOptions/properties/__dirname/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                    var c = s === i;
                }
                else
                    c = !0;
                if (c)
                    if (void 0 !== e.global) {
                        let a = e.global;
                        const s = i;
                        if (!1 !== a && !0 !== a && "warn" !== a) {
                            const e = { instancePath: t + "/global", schemaPath: "#/definitions/NodeOptions/properties/global/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                        c = s === i;
                    }
                    else
                        c = !0;
            }
        }
        else {
            const e = { instancePath: t, schemaPath: "#/definitions/NodeOptions/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            null === r ? r = [e] : r.push(e), i++;
        }
    p = a === i, l = l || p;
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, A.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), A.errors = r, 0 === i; }
function L(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return L.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    if (void 0 !== e.cacheGroups) {
        let a = e.cacheGroups;
        const s = i;
        if (i === s) {
            if (!a || "object" != typeof a || Array.isArray(a))
                return L.errors = [{ instancePath: t + "/cacheGroups", schemaPath: "#/properties/cacheGroups/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
            for (const e in a) {
                let s = a[e];
                const n = i, p = i;
                let c = !1;
                const h = i;
                if (i == i)
                    if (s && "object" == typeof s && !Array.isArray(s)) {
                        if (void 0 !== s.chunks) {
                            let a = s.chunks;
                            const n = i, m = i;
                            let p = !1;
                            const c = i;
                            if ("initial" !== a && "async" !== a && "all" !== a) {
                                const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/chunks", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/chunks/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                null === r ? r = [a] : r.push(a), i++;
                            }
                            var o = c === i;
                            if (p = p || o, !p) {
                                const s = i;
                                if (!(a instanceof Function)) {
                                    const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/chunks", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/chunks/anyOf/1/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                                    null === r ? r = [a] : r.push(a), i++;
                                }
                                o = s === i, p = p || o;
                            }
                            if (p)
                                i = m, null !== r && (m ? r.length = m : r = null);
                            else {
                                const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/chunks", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/chunks/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                null === r ? r = [a] : r.push(a), i++;
                            }
                            var l = n === i;
                        }
                        else
                            l = !0;
                        if (l) {
                            if (void 0 !== s.minChunks) {
                                let a = s.minChunks;
                                const n = i;
                                if (i === n)
                                    if ("number" == typeof a) {
                                        if (a < 1 || isNaN(a)) {
                                            const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/minChunks", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/minChunks/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" };
                                            null === r ? r = [a] : r.push(a), i++;
                                        }
                                    }
                                    else {
                                        const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/minChunks", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/minChunks/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                                        null === r ? r = [a] : r.push(a), i++;
                                    }
                                l = n === i;
                            }
                            else
                                l = !0;
                            if (l) {
                                if (void 0 !== s.name) {
                                    let a = s.name;
                                    const n = i, o = i;
                                    let p = !1;
                                    const c = i;
                                    if (!1 !== a) {
                                        const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/name/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                        null === r ? r = [a] : r.push(a), i++;
                                    }
                                    var m = c === i;
                                    if (p = p || m, !p) {
                                        const s = i;
                                        if ("string" != typeof a) {
                                            const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/name/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                            null === r ? r = [a] : r.push(a), i++;
                                        }
                                        if (m = s === i, p = p || m, !p) {
                                            const s = i;
                                            if (!(a instanceof Function)) {
                                                const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/name/anyOf/2/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                                                null === r ? r = [a] : r.push(a), i++;
                                            }
                                            m = s === i, p = p || m;
                                        }
                                    }
                                    if (p)
                                        i = o, null !== r && (o ? r.length = o : r = null);
                                    else {
                                        const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/name/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                        null === r ? r = [a] : r.push(a), i++;
                                    }
                                    l = n === i;
                                }
                                else
                                    l = !0;
                                if (l) {
                                    if (void 0 !== s.priority) {
                                        const a = i;
                                        if ("number" != typeof s.priority) {
                                            const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/priority", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/priority/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                                            null === r ? r = [a] : r.push(a), i++;
                                        }
                                        l = a === i;
                                    }
                                    else
                                        l = !0;
                                    if (l) {
                                        if (void 0 !== s.reuseExistingChunk) {
                                            const a = i;
                                            if ("boolean" != typeof s.reuseExistingChunk) {
                                                const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/reuseExistingChunk", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/reuseExistingChunk/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                null === r ? r = [a] : r.push(a), i++;
                                            }
                                            l = a === i;
                                        }
                                        else
                                            l = !0;
                                        if (l)
                                            if (void 0 !== s.test) {
                                                const a = i, n = i;
                                                let o = !1;
                                                const m = i;
                                                if (!(s.test instanceof RegExp)) {
                                                    const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/test", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/test/anyOf/0/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                                                    null === r ? r = [a] : r.push(a), i++;
                                                }
                                                if (o = o || m === i, o)
                                                    i = n, null !== r && (n ? r.length = n : r = null);
                                                else {
                                                    const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1") + "/test", schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/properties/test/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                    null === r ? r = [a] : r.push(a), i++;
                                                }
                                                l = a === i;
                                            }
                                            else
                                                l = !0;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/OptimizationSplitChunksCacheGroup/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                        null === r ? r = [a] : r.push(a), i++;
                    }
                if (c = c || h === i, !c) {
                    const a = { instancePath: t + "/cacheGroups/" + e.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/cacheGroups/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    return null === r ? r = [a] : r.push(a), i++, L.errors = r, !1;
                }
                if (i = p, null !== r && (p ? r.length = p : r = null), n !== i)
                    break;
            }
        }
        var p = s === i;
    }
    else
        p = !0;
    if (p) {
        if (void 0 !== e.chunks) {
            let a = e.chunks;
            const s = i, n = i;
            let o = !1;
            const l = i;
            if ("initial" !== a && "async" !== a && "all" !== a) {
                const e = { instancePath: t + "/chunks", schemaPath: "#/properties/chunks/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                null === r ? r = [e] : r.push(e), i++;
            }
            if (o = o || l === i, !o) {
                const e = { instancePath: t + "/chunks", schemaPath: "#/properties/chunks/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                return null === r ? r = [e] : r.push(e), i++, L.errors = r, !1;
            }
            i = n, null !== r && (n ? r.length = n : r = null), p = s === i;
        }
        else
            p = !0;
        if (p) {
            if (void 0 !== e.enforceSizeThreshold) {
                let a = e.enforceSizeThreshold;
                const s = i, n = i;
                let o = !1, l = null;
                const m = i, c = i;
                let h = !1;
                const u = i;
                if (i === u)
                    if ("number" == typeof a) {
                        if (a < 0 || isNaN(a)) {
                            const e = { instancePath: t + "/enforceSizeThreshold", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf/0/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                    }
                    else {
                        const e = { instancePath: t + "/enforceSizeThreshold", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf/0/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                if (h = h || u === i, h)
                    i = c, null !== r && (c ? r.length = c : r = null);
                else {
                    const e = { instancePath: t + "/enforceSizeThreshold", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    null === r ? r = [e] : r.push(e), i++;
                }
                if (m === i && (o = !0, l = 0), !o) {
                    const e = { instancePath: t + "/enforceSizeThreshold", schemaPath: "#/properties/enforceSizeThreshold/oneOf", keyword: "oneOf", params: { passingSchemas: l }, message: "must match exactly one schema in oneOf" };
                    return null === r ? r = [e] : r.push(e), i++, L.errors = r, !1;
                }
                i = n, null !== r && (n ? r.length = n : r = null), p = s === i;
            }
            else
                p = !0;
            if (p) {
                if (void 0 !== e.maxAsyncRequests) {
                    let a = e.maxAsyncRequests;
                    const s = i;
                    if (i === s) {
                        if ("number" != typeof a)
                            return L.errors = [{ instancePath: t + "/maxAsyncRequests", schemaPath: "#/properties/maxAsyncRequests/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                        if (a < 1 || isNaN(a))
                            return L.errors = [{ instancePath: t + "/maxAsyncRequests", schemaPath: "#/properties/maxAsyncRequests/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }], !1;
                    }
                    p = s === i;
                }
                else
                    p = !0;
                if (p) {
                    if (void 0 !== e.maxInitialRequests) {
                        let a = e.maxInitialRequests;
                        const s = i;
                        if (i === s) {
                            if ("number" != typeof a)
                                return L.errors = [{ instancePath: t + "/maxInitialRequests", schemaPath: "#/properties/maxInitialRequests/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                            if (a < 1 || isNaN(a))
                                return L.errors = [{ instancePath: t + "/maxInitialRequests", schemaPath: "#/properties/maxInitialRequests/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }], !1;
                        }
                        p = s === i;
                    }
                    else
                        p = !0;
                    if (p) {
                        if (void 0 !== e.minChunks) {
                            let a = e.minChunks;
                            const s = i;
                            if (i === s) {
                                if ("number" != typeof a)
                                    return L.errors = [{ instancePath: t + "/minChunks", schemaPath: "#/properties/minChunks/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                                if (a < 1 || isNaN(a))
                                    return L.errors = [{ instancePath: t + "/minChunks", schemaPath: "#/properties/minChunks/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }], !1;
                            }
                            p = s === i;
                        }
                        else
                            p = !0;
                        if (p) {
                            if (void 0 !== e.minRemainingSize) {
                                let a = e.minRemainingSize;
                                const s = i, n = i;
                                let o = !1, l = null;
                                const m = i, c = i;
                                let h = !1;
                                const u = i;
                                if (i === u)
                                    if ("number" == typeof a) {
                                        if (a < 0 || isNaN(a)) {
                                            const e = { instancePath: t + "/minRemainingSize", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf/0/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                    }
                                    else {
                                        const e = { instancePath: t + "/minRemainingSize", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf/0/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                if (h = h || u === i, h)
                                    i = c, null !== r && (c ? r.length = c : r = null);
                                else {
                                    const e = { instancePath: t + "/minRemainingSize", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                                if (m === i && (o = !0, l = 0), !o) {
                                    const e = { instancePath: t + "/minRemainingSize", schemaPath: "#/properties/minRemainingSize/oneOf", keyword: "oneOf", params: { passingSchemas: l }, message: "must match exactly one schema in oneOf" };
                                    return null === r ? r = [e] : r.push(e), i++, L.errors = r, !1;
                                }
                                i = n, null !== r && (n ? r.length = n : r = null), p = s === i;
                            }
                            else
                                p = !0;
                            if (p)
                                if (void 0 !== e.minSize) {
                                    let a = e.minSize;
                                    const s = i, n = i;
                                    let o = !1, l = null;
                                    const m = i, c = i;
                                    let h = !1;
                                    const u = i;
                                    if (i === u)
                                        if ("number" == typeof a) {
                                            if (a < 0 || isNaN(a)) {
                                                const e = { instancePath: t + "/minSize", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf/0/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" };
                                                null === r ? r = [e] : r.push(e), i++;
                                            }
                                        }
                                        else {
                                            const e = { instancePath: t + "/minSize", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf/0/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                    if (h = h || u === i, h)
                                        i = c, null !== r && (c ? r.length = c : r = null);
                                    else {
                                        const e = { instancePath: t + "/minSize", schemaPath: "#/definitions/OptimizationSplitChunksSizes/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                    if (m === i && (o = !0, l = 0), !o) {
                                        const e = { instancePath: t + "/minSize", schemaPath: "#/properties/minSize/oneOf", keyword: "oneOf", params: { passingSchemas: l }, message: "must match exactly one schema in oneOf" };
                                        return null === r ? r = [e] : r.push(e), i++, L.errors = r, !1;
                                    }
                                    i = n, null !== r && (n ? r.length = n : r = null), p = s === i;
                                }
                                else
                                    p = !0;
                        }
                    }
                }
            }
        }
    }
} return L.errors = r, 0 === i; }
function C(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return C.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    if (void 0 !== e.chunkIds) {
        let a = e.chunkIds;
        const s = i;
        if ("named" !== a && "deterministic" !== a)
            return C.errors = [{ instancePath: t + "/chunkIds", schemaPath: "#/properties/chunkIds/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' }], !1;
        var o = s === i;
    }
    else
        o = !0;
    if (o) {
        if (void 0 !== e.minimize) {
            const a = i;
            if ("boolean" != typeof e.minimize)
                return C.errors = [{ instancePath: t + "/minimize", schemaPath: "#/properties/minimize/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
            o = a === i;
        }
        else
            o = !0;
        if (o) {
            if (void 0 !== e.minimizer) {
                let a = e.minimizer;
                const s = i;
                if (i === s) {
                    if (!Array.isArray(a))
                        return C.errors = [{ instancePath: t + "/minimizer", schemaPath: "#/properties/minimizer/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                    {
                        const e = a.length;
                        for (let s = 0; s < e; s++) {
                            let e = a[s];
                            const n = i, o = i;
                            let m = !1;
                            const p = i;
                            if ("..." !== e) {
                                const e = { instancePath: t + "/minimizer/" + s, schemaPath: "#/properties/minimizer/items/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                null === r ? r = [e] : r.push(e), i++;
                            }
                            var l = p === i;
                            if (m = m || l, !m) {
                                const a = i;
                                if (i == i)
                                    if (e && "object" == typeof e && !Array.isArray(e)) {
                                        let a;
                                        if (void 0 === e.apply && (a = "apply")) {
                                            const e = { instancePath: t + "/minimizer/" + s, schemaPath: "#/definitions/RspackPluginInstance/required", keyword: "required", params: { missingProperty: a }, message: "must have required property '" + a + "'" };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                        else if (void 0 !== e.apply && !(e.apply instanceof Function)) {
                                            const e = { instancePath: t + "/minimizer/" + s + "/apply", schemaPath: "#/definitions/RspackPluginInstance/properties/apply/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                    }
                                    else {
                                        const e = { instancePath: t + "/minimizer/" + s, schemaPath: "#/definitions/RspackPluginInstance/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                if (l = a === i, m = m || l, !m) {
                                    const a = i;
                                    if (!(e instanceof Function)) {
                                        const e = { instancePath: t + "/minimizer/" + s, schemaPath: "#/definitions/RspackPluginFunction/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                    l = a === i, m = m || l;
                                }
                            }
                            if (!m) {
                                const e = { instancePath: t + "/minimizer/" + s, schemaPath: "#/properties/minimizer/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                return null === r ? r = [e] : r.push(e), i++, C.errors = r, !1;
                            }
                            if (i = o, null !== r && (o ? r.length = o : r = null), n !== i)
                                break;
                        }
                    }
                }
                o = s === i;
            }
            else
                o = !0;
            if (o) {
                if (void 0 !== e.moduleIds) {
                    let a = e.moduleIds;
                    const s = i;
                    if ("named" !== a && "deterministic" !== a)
                        return C.errors = [{ instancePath: t + "/moduleIds", schemaPath: "#/properties/moduleIds/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' }], !1;
                    o = s === i;
                }
                else
                    o = !0;
                if (o) {
                    if (void 0 !== e.removeAvailableModules) {
                        const a = i;
                        if ("boolean" != typeof e.removeAvailableModules)
                            return C.errors = [{ instancePath: t + "/removeAvailableModules", schemaPath: "#/properties/removeAvailableModules/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                        o = a === i;
                    }
                    else
                        o = !0;
                    if (o) {
                        if (void 0 !== e.runtimeChunk) {
                            let a = e.runtimeChunk;
                            const s = i, n = i;
                            let l = !1;
                            const c = i;
                            if ("single" !== a && "multiple" !== a) {
                                const e = { instancePath: t + "/runtimeChunk", schemaPath: "#/definitions/OptimizationRuntimeChunk/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                null === r ? r = [e] : r.push(e), i++;
                            }
                            var m = c === i;
                            if (l = l || m, !l) {
                                const e = i;
                                if ("boolean" != typeof a) {
                                    const e = { instancePath: t + "/runtimeChunk", schemaPath: "#/definitions/OptimizationRuntimeChunk/anyOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                                if (m = e === i, l = l || m, !l) {
                                    const e = i;
                                    if (i === e)
                                        if (a && "object" == typeof a && !Array.isArray(a)) {
                                            const e = i;
                                            for (const e in a)
                                                if ("name" !== e) {
                                                    const a = { instancePath: t + "/runtimeChunk", schemaPath: "#/definitions/OptimizationRuntimeChunk/anyOf/2/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: e }, message: "must NOT have additional properties" };
                                                    null === r ? r = [a] : r.push(a), i++;
                                                    break;
                                                }
                                            if (e === i && void 0 !== a.name) {
                                                let e = a.name;
                                                const s = i;
                                                let n = !1;
                                                const o = i;
                                                if ("string" != typeof e) {
                                                    const e = { instancePath: t + "/runtimeChunk/name", schemaPath: "#/definitions/OptimizationRuntimeChunk/anyOf/2/properties/name/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                    null === r ? r = [e] : r.push(e), i++;
                                                }
                                                var p = o === i;
                                                if (n = n || p, !n) {
                                                    const a = i;
                                                    if (!(e instanceof Function)) {
                                                        const e = { instancePath: t + "/runtimeChunk/name", schemaPath: "#/definitions/OptimizationRuntimeChunk/anyOf/2/properties/name/anyOf/1/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                                                        null === r ? r = [e] : r.push(e), i++;
                                                    }
                                                    p = a === i, n = n || p;
                                                }
                                                if (n)
                                                    i = s, null !== r && (s ? r.length = s : r = null);
                                                else {
                                                    const e = { instancePath: t + "/runtimeChunk/name", schemaPath: "#/definitions/OptimizationRuntimeChunk/anyOf/2/properties/name/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                    null === r ? r = [e] : r.push(e), i++;
                                                }
                                            }
                                        }
                                        else {
                                            const e = { instancePath: t + "/runtimeChunk", schemaPath: "#/definitions/OptimizationRuntimeChunk/anyOf/2/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                    m = e === i, l = l || m;
                                }
                            }
                            if (!l) {
                                const e = { instancePath: t + "/runtimeChunk", schemaPath: "#/definitions/OptimizationRuntimeChunk/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                return null === r ? r = [e] : r.push(e), i++, C.errors = r, !1;
                            }
                            i = n, null !== r && (n ? r.length = n : r = null), o = s === i;
                        }
                        else
                            o = !0;
                        if (o) {
                            if (void 0 !== e.sideEffects) {
                                let a = e.sideEffects;
                                const s = i, n = i;
                                let l = !1;
                                const m = i;
                                if ("flag" !== a) {
                                    const e = { instancePath: t + "/sideEffects", schemaPath: "#/properties/sideEffects/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                                var c = m === i;
                                if (l = l || c, !l) {
                                    const e = i;
                                    if ("boolean" != typeof a) {
                                        const e = { instancePath: t + "/sideEffects", schemaPath: "#/properties/sideEffects/anyOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                    c = e === i, l = l || c;
                                }
                                if (!l) {
                                    const e = { instancePath: t + "/sideEffects", schemaPath: "#/properties/sideEffects/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                    return null === r ? r = [e] : r.push(e), i++, C.errors = r, !1;
                                }
                                i = n, null !== r && (n ? r.length = n : r = null), o = s === i;
                            }
                            else
                                o = !0;
                            if (o)
                                if (void 0 !== e.splitChunks) {
                                    let a = e.splitChunks;
                                    const s = i, l = i;
                                    let m = !1;
                                    const p = i;
                                    if (!1 !== a) {
                                        const e = { instancePath: t + "/splitChunks", schemaPath: "#/properties/splitChunks/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                    var h = p === i;
                                    if (m = m || h, !m) {
                                        const s = i;
                                        L(a, { instancePath: t + "/splitChunks", parentData: e, parentDataProperty: "splitChunks", rootData: n }) || (r = null === r ? L.errors : r.concat(L.errors), i = r.length), h = s === i, m = m || h;
                                    }
                                    if (!m) {
                                        const e = { instancePath: t + "/splitChunks", schemaPath: "#/properties/splitChunks/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                        return null === r ? r = [e] : r.push(e), i++, C.errors = r, !1;
                                    }
                                    i = l, null !== r && (l ? r.length = l : r = null), o = s === i;
                                }
                                else
                                    o = !0;
                        }
                    }
                }
            }
        }
    }
} return C.errors = r, 0 === i; }
function S(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; if ("string" != typeof e) {
    const e = { instancePath: t, schemaPath: "#/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
    null === r ? r = [e] : r.push(e), i++;
} var p = m === i; if (l = l || p, !l) {
    const a = i;
    if (i == i)
        if (e && "object" == typeof e && !Array.isArray(e)) {
            const a = i;
            for (const a in e)
                if ("amd" !== a && "commonjs" !== a && "commonjs2" !== a && "root" !== a) {
                    const e = { instancePath: t, schemaPath: "#/definitions/LibraryCustomUmdCommentObject/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" };
                    null === r ? r = [e] : r.push(e), i++;
                    break;
                }
            if (a === i) {
                if (void 0 !== e.amd) {
                    const a = i;
                    if ("string" != typeof e.amd) {
                        const e = { instancePath: t + "/amd", schemaPath: "#/definitions/LibraryCustomUmdCommentObject/properties/amd/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                    var c = a === i;
                }
                else
                    c = !0;
                if (c) {
                    if (void 0 !== e.commonjs) {
                        const a = i;
                        if ("string" != typeof e.commonjs) {
                            const e = { instancePath: t + "/commonjs", schemaPath: "#/definitions/LibraryCustomUmdCommentObject/properties/commonjs/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                        c = a === i;
                    }
                    else
                        c = !0;
                    if (c) {
                        if (void 0 !== e.commonjs2) {
                            const a = i;
                            if ("string" != typeof e.commonjs2) {
                                const e = { instancePath: t + "/commonjs2", schemaPath: "#/definitions/LibraryCustomUmdCommentObject/properties/commonjs2/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                null === r ? r = [e] : r.push(e), i++;
                            }
                            c = a === i;
                        }
                        else
                            c = !0;
                        if (c)
                            if (void 0 !== e.root) {
                                const a = i;
                                if ("string" != typeof e.root) {
                                    const e = { instancePath: t + "/root", schemaPath: "#/definitions/LibraryCustomUmdCommentObject/properties/root/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                                c = a === i;
                            }
                            else
                                c = !0;
                    }
                }
            }
        }
        else {
            const e = { instancePath: t, schemaPath: "#/definitions/LibraryCustomUmdCommentObject/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            null === r ? r = [e] : r.push(e), i++;
        }
    p = a === i, l = l || p;
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, S.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), S.errors = r, 0 === i; }
function x(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1, m = null; const p = i, c = i; let h = !1; const u = i; if (i === u)
    if ("string" == typeof e) {
        if (e.length < 1) {
            const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/0/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
            null === r ? r = [e] : r.push(e), i++;
        }
    }
    else {
        const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        null === r ? r = [e] : r.push(e), i++;
    } var y = u === i; if (h = h || y, !h) {
    const a = i;
    if (!(e instanceof Function)) {
        const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/1/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
        null === r ? r = [e] : r.push(e), i++;
    }
    y = a === i, h = h || y;
} if (h)
    i = c, null !== r && (c ? r.length = c : r = null);
else {
    const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    null === r ? r = [e] : r.push(e), i++;
} if (p === i && (l = !0, m = 0), !l) {
    const e = { instancePath: t, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
    return null === r ? r = [e] : r.push(e), i++, x.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), x.errors = r, 0 === i; }
function R(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1, m = null; const p = i, c = i; let h = !1; const u = i; if (i === u)
    if ("string" == typeof e) {
        if (e.length < 1) {
            const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/0/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
            null === r ? r = [e] : r.push(e), i++;
        }
    }
    else {
        const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        null === r ? r = [e] : r.push(e), i++;
    } var y = u === i; if (h = h || y, !h) {
    const a = i;
    if (!(e instanceof Function)) {
        const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/1/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
        null === r ? r = [e] : r.push(e), i++;
    }
    y = a === i, h = h || y;
} if (h)
    i = c, null !== r && (c ? r.length = c : r = null);
else {
    const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    null === r ? r = [e] : r.push(e), i++;
} if (p === i && (l = !0, m = 0), !l) {
    const e = { instancePath: t, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
    return null === r ? r = [e] : r.push(e), i++, R.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), R.errors = r, 0 === i; }
function T(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1, m = null; const p = i, c = i; let h = !1; const u = i; if (i === u)
    if ("string" == typeof e) {
        if (e.length < 1) {
            const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/0/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
            null === r ? r = [e] : r.push(e), i++;
        }
    }
    else {
        const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        null === r ? r = [e] : r.push(e), i++;
    } var y = u === i; if (h = h || y, !h) {
    const a = i;
    if (!(e instanceof Function)) {
        const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/1/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
        null === r ? r = [e] : r.push(e), i++;
    }
    y = a === i, h = h || y;
} if (h)
    i = c, null !== r && (c ? r.length = c : r = null);
else {
    const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    null === r ? r = [e] : r.push(e), i++;
} if (p === i && (l = !0, m = 0), !l) {
    const e = { instancePath: t, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
    return null === r ? r = [e] : r.push(e), i++, T.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), T.errors = r, 0 === i; }
function F(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!Array.isArray(e))
        return F.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
    {
        const a = e.length;
        for (let s = 0; s < a; s++) {
            let a = e[s];
            const n = i, l = i;
            let m = !1;
            const p = i;
            if ("var" !== a && "module" !== a && "assign" !== a && "assign-properties" !== a && "this" !== a && "window" !== a && "self" !== a && "global" !== a && "commonjs" !== a && "commonjs2" !== a && "commonjs-module" !== a && "commonjs-static" !== a && "amd" !== a && "amd-require" !== a && "umd" !== a && "umd2" !== a && "jsonp" !== a && "system" !== a) {
                const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/LibraryType/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                null === r ? r = [e] : r.push(e), i++;
            }
            var o = p === i;
            if (m = m || o, !m) {
                const e = i;
                if ("string" != typeof a) {
                    const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/LibraryType/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    null === r ? r = [e] : r.push(e), i++;
                }
                o = e === i, m = m || o;
            }
            if (!m) {
                const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/LibraryType/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                return null === r ? r = [e] : r.push(e), i++, F.errors = r, !1;
            }
            if (i = l, null !== r && (l ? r.length = l : r = null), n !== i)
                break;
        }
    }
} return F.errors = r, 0 === i; }
function z(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1, m = null; const p = i, c = i; let h = !1; const u = i; if (i === u)
    if ("string" == typeof e) {
        if (e.length < 1) {
            const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/0/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
            null === r ? r = [e] : r.push(e), i++;
        }
    }
    else {
        const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        null === r ? r = [e] : r.push(e), i++;
    } var y = u === i; if (h = h || y, !h) {
    const a = i;
    if (!(e instanceof Function)) {
        const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf/1/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
        null === r ? r = [e] : r.push(e), i++;
    }
    y = a === i, h = h || y;
} if (h)
    i = c, null !== r && (c ? r.length = c : r = null);
else {
    const e = { instancePath: t, schemaPath: "#/definitions/FilenameTemplate/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    null === r ? r = [e] : r.push(e), i++;
} if (p === i && (l = !0, m = 0), !l) {
    const e = { instancePath: t, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
    return null === r ? r = [e] : r.push(e), i++, z.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), z.errors = r, 0 === i; }
function E(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; if (i === m)
    if (Array.isArray(e))
        if (e.length < 1) {
            const e = { instancePath: t, schemaPath: "#/anyOf/0/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
            null === r ? r = [e] : r.push(e), i++;
        }
        else {
            const a = e.length;
            for (let s = 0; s < a; s++) {
                let a = e[s];
                const n = i;
                if (i === n)
                    if ("string" == typeof a) {
                        if (a.length < 1) {
                            const e = { instancePath: t + "/" + s, schemaPath: "#/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                    }
                    else {
                        const e = { instancePath: t + "/" + s, schemaPath: "#/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                if (n !== i)
                    break;
            }
        }
    else {
        const e = { instancePath: t, schemaPath: "#/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
        null === r ? r = [e] : r.push(e), i++;
    } var p = m === i; if (l = l || p, !l) {
    const a = i;
    if (i === a)
        if ("string" == typeof e) {
            if (e.length < 1) {
                const e = { instancePath: t, schemaPath: "#/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                null === r ? r = [e] : r.push(e), i++;
            }
        }
        else {
            const e = { instancePath: t, schemaPath: "#/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            null === r ? r = [e] : r.push(e), i++;
        }
    if (p = a === i, l = l || p, !l) {
        const a = i;
        if (i == i)
            if (e && "object" == typeof e && !Array.isArray(e)) {
                const a = i;
                for (const a in e)
                    if ("amd" !== a && "commonjs" !== a && "root" !== a) {
                        const e = { instancePath: t, schemaPath: "#/definitions/LibraryCustomUmdObject/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" };
                        null === r ? r = [e] : r.push(e), i++;
                        break;
                    }
                if (a === i) {
                    if (void 0 !== e.amd) {
                        let a = e.amd;
                        const s = i;
                        if (i === s)
                            if ("string" == typeof a) {
                                if (a.length < 1) {
                                    const e = { instancePath: t + "/amd", schemaPath: "#/definitions/LibraryCustomUmdObject/properties/amd/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                            }
                            else {
                                const e = { instancePath: t + "/amd", schemaPath: "#/definitions/LibraryCustomUmdObject/properties/amd/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                null === r ? r = [e] : r.push(e), i++;
                            }
                        var c = s === i;
                    }
                    else
                        c = !0;
                    if (c) {
                        if (void 0 !== e.commonjs) {
                            let a = e.commonjs;
                            const s = i;
                            if (i === s)
                                if ("string" == typeof a) {
                                    if (a.length < 1) {
                                        const e = { instancePath: t + "/commonjs", schemaPath: "#/definitions/LibraryCustomUmdObject/properties/commonjs/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                }
                                else {
                                    const e = { instancePath: t + "/commonjs", schemaPath: "#/definitions/LibraryCustomUmdObject/properties/commonjs/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                            c = s === i;
                        }
                        else
                            c = !0;
                        if (c)
                            if (void 0 !== e.root) {
                                let a = e.root;
                                const s = i, n = i;
                                let o = !1;
                                const l = i;
                                if (i === l)
                                    if (Array.isArray(a)) {
                                        const e = a.length;
                                        for (let s = 0; s < e; s++) {
                                            let e = a[s];
                                            const n = i;
                                            if (i === n)
                                                if ("string" == typeof e) {
                                                    if (e.length < 1) {
                                                        const e = { instancePath: t + "/root/" + s, schemaPath: "#/definitions/LibraryCustomUmdObject/properties/root/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                        null === r ? r = [e] : r.push(e), i++;
                                                    }
                                                }
                                                else {
                                                    const e = { instancePath: t + "/root/" + s, schemaPath: "#/definitions/LibraryCustomUmdObject/properties/root/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                    null === r ? r = [e] : r.push(e), i++;
                                                }
                                            if (n !== i)
                                                break;
                                        }
                                    }
                                    else {
                                        const e = { instancePath: t + "/root", schemaPath: "#/definitions/LibraryCustomUmdObject/properties/root/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                var h = l === i;
                                if (o = o || h, !o) {
                                    const e = i;
                                    if (i === e)
                                        if ("string" == typeof a) {
                                            if (a.length < 1) {
                                                const e = { instancePath: t + "/root", schemaPath: "#/definitions/LibraryCustomUmdObject/properties/root/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                null === r ? r = [e] : r.push(e), i++;
                                            }
                                        }
                                        else {
                                            const e = { instancePath: t + "/root", schemaPath: "#/definitions/LibraryCustomUmdObject/properties/root/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                    h = e === i, o = o || h;
                                }
                                if (o)
                                    i = n, null !== r && (n ? r.length = n : r = null);
                                else {
                                    const e = { instancePath: t + "/root", schemaPath: "#/definitions/LibraryCustomUmdObject/properties/root/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                                c = s === i;
                            }
                            else
                                c = !0;
                    }
                }
            }
            else {
                const e = { instancePath: t, schemaPath: "#/definitions/LibraryCustomUmdObject/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                null === r ? r = [e] : r.push(e), i++;
            }
        p = a === i, l = l || p;
    }
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, E.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), E.errors = r, 0 === i; }
function I(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return I.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    {
        let a;
        if (void 0 === e.type && (a = "type"))
            return I.errors = [{ instancePath: t, schemaPath: "#/required", keyword: "required", params: { missingProperty: a }, message: "must have required property '" + a + "'" }], !1;
        {
            const a = i;
            for (const a in e)
                if ("auxiliaryComment" !== a && "export" !== a && "name" !== a && "type" !== a && "umdNamedDefine" !== a)
                    return I.errors = [{ instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: a }, message: "must NOT have additional properties" }], !1;
            if (a === i) {
                if (void 0 !== e.auxiliaryComment) {
                    const a = i;
                    S(e.auxiliaryComment, { instancePath: t + "/auxiliaryComment", parentData: e, parentDataProperty: "auxiliaryComment", rootData: n }) || (r = null === r ? S.errors : r.concat(S.errors), i = r.length);
                    var o = a === i;
                }
                else
                    o = !0;
                if (o) {
                    if (void 0 !== e.export) {
                        let a = e.export;
                        const s = i, n = i;
                        let m = !1;
                        const p = i;
                        if (i === p)
                            if (Array.isArray(a)) {
                                const e = a.length;
                                for (let s = 0; s < e; s++) {
                                    let e = a[s];
                                    const n = i;
                                    if (i === n)
                                        if ("string" == typeof e) {
                                            if (e.length < 1) {
                                                const e = { instancePath: t + "/export/" + s, schemaPath: "#/definitions/LibraryExport/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                null === r ? r = [e] : r.push(e), i++;
                                            }
                                        }
                                        else {
                                            const e = { instancePath: t + "/export/" + s, schemaPath: "#/definitions/LibraryExport/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                    if (n !== i)
                                        break;
                                }
                            }
                            else {
                                const e = { instancePath: t + "/export", schemaPath: "#/definitions/LibraryExport/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                null === r ? r = [e] : r.push(e), i++;
                            }
                        var l = p === i;
                        if (m = m || l, !m) {
                            const e = i;
                            if (i === e)
                                if ("string" == typeof a) {
                                    if (a.length < 1) {
                                        const e = { instancePath: t + "/export", schemaPath: "#/definitions/LibraryExport/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                }
                                else {
                                    const e = { instancePath: t + "/export", schemaPath: "#/definitions/LibraryExport/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                            l = e === i, m = m || l;
                        }
                        if (!m) {
                            const e = { instancePath: t + "/export", schemaPath: "#/definitions/LibraryExport/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                            return null === r ? r = [e] : r.push(e), i++, I.errors = r, !1;
                        }
                        i = n, null !== r && (n ? r.length = n : r = null), o = s === i;
                    }
                    else
                        o = !0;
                    if (o) {
                        if (void 0 !== e.name) {
                            const a = i;
                            E(e.name, { instancePath: t + "/name", parentData: e, parentDataProperty: "name", rootData: n }) || (r = null === r ? E.errors : r.concat(E.errors), i = r.length), o = a === i;
                        }
                        else
                            o = !0;
                        if (o) {
                            if (void 0 !== e.type) {
                                let a = e.type;
                                const s = i, n = i;
                                let l = !1;
                                const p = i;
                                if ("var" !== a && "module" !== a && "assign" !== a && "assign-properties" !== a && "this" !== a && "window" !== a && "self" !== a && "global" !== a && "commonjs" !== a && "commonjs2" !== a && "commonjs-module" !== a && "commonjs-static" !== a && "amd" !== a && "amd-require" !== a && "umd" !== a && "umd2" !== a && "jsonp" !== a && "system" !== a) {
                                    const e = { instancePath: t + "/type", schemaPath: "#/definitions/LibraryType/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                                var m = p === i;
                                if (l = l || m, !l) {
                                    const e = i;
                                    if ("string" != typeof a) {
                                        const e = { instancePath: t + "/type", schemaPath: "#/definitions/LibraryType/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                    m = e === i, l = l || m;
                                }
                                if (!l) {
                                    const e = { instancePath: t + "/type", schemaPath: "#/definitions/LibraryType/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                    return null === r ? r = [e] : r.push(e), i++, I.errors = r, !1;
                                }
                                i = n, null !== r && (n ? r.length = n : r = null), o = s === i;
                            }
                            else
                                o = !0;
                            if (o)
                                if (void 0 !== e.umdNamedDefine) {
                                    const a = i;
                                    if ("boolean" != typeof e.umdNamedDefine)
                                        return I.errors = [{ instancePath: t + "/umdNamedDefine", schemaPath: "#/definitions/UmdNamedDefine/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                    o = a === i;
                                }
                                else
                                    o = !0;
                        }
                    }
                }
            }
        }
    }
} return I.errors = r, 0 === i; }
function N(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; E(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? E.errors : r.concat(E.errors), i = r.length); var p = m === i; if (l = l || p, !l) {
    const o = i;
    I(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? I.errors : r.concat(I.errors), i = r.length), p = o === i, l = l || p;
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, N.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), N.errors = r, 0 === i; }
function q(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; if ("auto" !== e) {
    const e = { instancePath: t, schemaPath: "#/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
    null === r ? r = [e] : r.push(e), i++;
} var p = m === i; if (l = l || p, !l) {
    const a = i, s = i;
    let n = !1;
    const o = i;
    if ("string" != typeof e) {
        const e = { instancePath: t, schemaPath: "#/definitions/RawPublicPath/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
        null === r ? r = [e] : r.push(e), i++;
    }
    if (n = n || o === i, n)
        i = s, null !== r && (s ? r.length = s : r = null);
    else {
        const e = { instancePath: t, schemaPath: "#/definitions/RawPublicPath/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
        null === r ? r = [e] : r.push(e), i++;
    }
    p = a === i, l = l || p;
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, q.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), q.errors = r, 0 === i; }
function G(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!e || "object" != typeof e || Array.isArray(e))
        return G.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    if (void 0 !== e.assetModuleFilename) {
        const a = i, s = i;
        let n = !1;
        const l = i;
        if ("string" != typeof e.assetModuleFilename) {
            const e = { instancePath: t + "/assetModuleFilename", schemaPath: "#/definitions/AssetModuleFilename/anyOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            null === r ? r = [e] : r.push(e), i++;
        }
        if (n = n || l === i, !n) {
            const e = { instancePath: t + "/assetModuleFilename", schemaPath: "#/definitions/AssetModuleFilename/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
            return null === r ? r = [e] : r.push(e), i++, G.errors = r, !1;
        }
        i = s, null !== r && (s ? r.length = s : r = null);
        var o = a === i;
    }
    else
        o = !0;
    if (o) {
        if (void 0 !== e.auxiliaryComment) {
            const a = i, s = i;
            let l = !1, m = null;
            const p = i;
            if (S(e.auxiliaryComment, { instancePath: t + "/auxiliaryComment", parentData: e, parentDataProperty: "auxiliaryComment", rootData: n }) || (r = null === r ? S.errors : r.concat(S.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
                const e = { instancePath: t + "/auxiliaryComment", schemaPath: "#/properties/auxiliaryComment/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
                return null === r ? r = [e] : r.push(e), i++, G.errors = r, !1;
            }
            i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
        }
        else
            o = !0;
        if (o) {
            if (void 0 !== e.chunkFilename) {
                const a = i;
                x(e.chunkFilename, { instancePath: t + "/chunkFilename", parentData: e, parentDataProperty: "chunkFilename", rootData: n }) || (r = null === r ? x.errors : r.concat(x.errors), i = r.length), o = a === i;
            }
            else
                o = !0;
            if (o) {
                if (void 0 !== e.cssChunkFilename) {
                    const a = i;
                    R(e.cssChunkFilename, { instancePath: t + "/cssChunkFilename", parentData: e, parentDataProperty: "cssChunkFilename", rootData: n }) || (r = null === r ? R.errors : r.concat(R.errors), i = r.length), o = a === i;
                }
                else
                    o = !0;
                if (o) {
                    if (void 0 !== e.cssFilename) {
                        const a = i;
                        T(e.cssFilename, { instancePath: t + "/cssFilename", parentData: e, parentDataProperty: "cssFilename", rootData: n }) || (r = null === r ? T.errors : r.concat(T.errors), i = r.length), o = a === i;
                    }
                    else
                        o = !0;
                    if (o) {
                        if (void 0 !== e.enabledLibraryTypes) {
                            const a = i;
                            F(e.enabledLibraryTypes, { instancePath: t + "/enabledLibraryTypes", parentData: e, parentDataProperty: "enabledLibraryTypes", rootData: n }) || (r = null === r ? F.errors : r.concat(F.errors), i = r.length), o = a === i;
                        }
                        else
                            o = !0;
                        if (o) {
                            if (void 0 !== e.filename) {
                                const a = i;
                                z(e.filename, { instancePath: t + "/filename", parentData: e, parentDataProperty: "filename", rootData: n }) || (r = null === r ? z.errors : r.concat(z.errors), i = r.length), o = a === i;
                            }
                            else
                                o = !0;
                            if (o) {
                                if (void 0 !== e.globalObject) {
                                    let a = e.globalObject;
                                    const s = i;
                                    if (i == i) {
                                        if ("string" != typeof a)
                                            return G.errors = [{ instancePath: t + "/globalObject", schemaPath: "#/definitions/GlobalObject/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                        if (a.length < 1)
                                            return G.errors = [{ instancePath: t + "/globalObject", schemaPath: "#/definitions/GlobalObject/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' }], !1;
                                    }
                                    o = s === i;
                                }
                                else
                                    o = !0;
                                if (o) {
                                    if (void 0 !== e.importFunctionName) {
                                        const a = i;
                                        if ("string" != typeof e.importFunctionName)
                                            return G.errors = [{ instancePath: t + "/importFunctionName", schemaPath: "#/definitions/ImportFunctionName/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                        o = a === i;
                                    }
                                    else
                                        o = !0;
                                    if (o) {
                                        if (void 0 !== e.library) {
                                            const a = i;
                                            N(e.library, { instancePath: t + "/library", parentData: e, parentDataProperty: "library", rootData: n }) || (r = null === r ? N.errors : r.concat(N.errors), i = r.length), o = a === i;
                                        }
                                        else
                                            o = !0;
                                        if (o) {
                                            if (void 0 !== e.libraryExport) {
                                                let a = e.libraryExport;
                                                const s = i, n = i;
                                                let m = !1, p = null;
                                                const c = i, h = i;
                                                let u = !1;
                                                const y = i;
                                                if (i === y)
                                                    if (Array.isArray(a)) {
                                                        const e = a.length;
                                                        for (let s = 0; s < e; s++) {
                                                            let e = a[s];
                                                            const n = i;
                                                            if (i === n)
                                                                if ("string" == typeof e) {
                                                                    if (e.length < 1) {
                                                                        const e = { instancePath: t + "/libraryExport/" + s, schemaPath: "#/definitions/LibraryExport/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                                        null === r ? r = [e] : r.push(e), i++;
                                                                    }
                                                                }
                                                                else {
                                                                    const e = { instancePath: t + "/libraryExport/" + s, schemaPath: "#/definitions/LibraryExport/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                    null === r ? r = [e] : r.push(e), i++;
                                                                }
                                                            if (n !== i)
                                                                break;
                                                        }
                                                    }
                                                    else {
                                                        const e = { instancePath: t + "/libraryExport", schemaPath: "#/definitions/LibraryExport/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                        null === r ? r = [e] : r.push(e), i++;
                                                    }
                                                var l = y === i;
                                                if (u = u || l, !u) {
                                                    const e = i;
                                                    if (i === e)
                                                        if ("string" == typeof a) {
                                                            if (a.length < 1) {
                                                                const e = { instancePath: t + "/libraryExport", schemaPath: "#/definitions/LibraryExport/anyOf/1/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                                null === r ? r = [e] : r.push(e), i++;
                                                            }
                                                        }
                                                        else {
                                                            const e = { instancePath: t + "/libraryExport", schemaPath: "#/definitions/LibraryExport/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                            null === r ? r = [e] : r.push(e), i++;
                                                        }
                                                    l = e === i, u = u || l;
                                                }
                                                if (u)
                                                    i = h, null !== r && (h ? r.length = h : r = null);
                                                else {
                                                    const e = { instancePath: t + "/libraryExport", schemaPath: "#/definitions/LibraryExport/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                    null === r ? r = [e] : r.push(e), i++;
                                                }
                                                if (c === i && (m = !0, p = 0), !m) {
                                                    const e = { instancePath: t + "/libraryExport", schemaPath: "#/properties/libraryExport/oneOf", keyword: "oneOf", params: { passingSchemas: p }, message: "must match exactly one schema in oneOf" };
                                                    return null === r ? r = [e] : r.push(e), i++, G.errors = r, !1;
                                                }
                                                i = n, null !== r && (n ? r.length = n : r = null), o = s === i;
                                            }
                                            else
                                                o = !0;
                                            if (o) {
                                                if (void 0 !== e.libraryTarget) {
                                                    let a = e.libraryTarget;
                                                    const s = i, n = i;
                                                    let l = !1, p = null;
                                                    const c = i, h = i;
                                                    let u = !1;
                                                    const y = i;
                                                    if ("var" !== a && "module" !== a && "assign" !== a && "assign-properties" !== a && "this" !== a && "window" !== a && "self" !== a && "global" !== a && "commonjs" !== a && "commonjs2" !== a && "commonjs-module" !== a && "commonjs-static" !== a && "amd" !== a && "amd-require" !== a && "umd" !== a && "umd2" !== a && "jsonp" !== a && "system" !== a) {
                                                        const e = { instancePath: t + "/libraryTarget", schemaPath: "#/definitions/LibraryType/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                                        null === r ? r = [e] : r.push(e), i++;
                                                    }
                                                    var m = y === i;
                                                    if (u = u || m, !u) {
                                                        const e = i;
                                                        if ("string" != typeof a) {
                                                            const e = { instancePath: t + "/libraryTarget", schemaPath: "#/definitions/LibraryType/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                            null === r ? r = [e] : r.push(e), i++;
                                                        }
                                                        m = e === i, u = u || m;
                                                    }
                                                    if (u)
                                                        i = h, null !== r && (h ? r.length = h : r = null);
                                                    else {
                                                        const e = { instancePath: t + "/libraryTarget", schemaPath: "#/definitions/LibraryType/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                        null === r ? r = [e] : r.push(e), i++;
                                                    }
                                                    if (c === i && (l = !0, p = 0), !l) {
                                                        const e = { instancePath: t + "/libraryTarget", schemaPath: "#/properties/libraryTarget/oneOf", keyword: "oneOf", params: { passingSchemas: p }, message: "must match exactly one schema in oneOf" };
                                                        return null === r ? r = [e] : r.push(e), i++, G.errors = r, !1;
                                                    }
                                                    i = n, null !== r && (n ? r.length = n : r = null), o = s === i;
                                                }
                                                else
                                                    o = !0;
                                                if (o) {
                                                    if (void 0 !== e.module) {
                                                        const a = i;
                                                        if ("boolean" != typeof e.module)
                                                            return G.errors = [{ instancePath: t + "/module", schemaPath: "#/definitions/OutputModule/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                        o = a === i;
                                                    }
                                                    else
                                                        o = !0;
                                                    if (o) {
                                                        if (void 0 !== e.path) {
                                                            const a = i;
                                                            if ("string" != typeof e.path)
                                                                return G.errors = [{ instancePath: t + "/path", schemaPath: "#/definitions/Path/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                            o = a === i;
                                                        }
                                                        else
                                                            o = !0;
                                                        if (o) {
                                                            if (void 0 !== e.publicPath) {
                                                                const a = i;
                                                                q(e.publicPath, { instancePath: t + "/publicPath", parentData: e, parentDataProperty: "publicPath", rootData: n }) || (r = null === r ? q.errors : r.concat(q.errors), i = r.length), o = a === i;
                                                            }
                                                            else
                                                                o = !0;
                                                            if (o) {
                                                                if (void 0 !== e.strictModuleErrorHandling) {
                                                                    const a = i;
                                                                    if ("boolean" != typeof e.strictModuleErrorHandling)
                                                                        return G.errors = [{ instancePath: t + "/strictModuleErrorHandling", schemaPath: "#/definitions/StrictModuleErrorHandling/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                                    o = a === i;
                                                                }
                                                                else
                                                                    o = !0;
                                                                if (o) {
                                                                    if (void 0 !== e.umdNamedDefine) {
                                                                        const a = i, s = i;
                                                                        let n = !1, l = null;
                                                                        const m = i;
                                                                        if ("boolean" != typeof e.umdNamedDefine) {
                                                                            const e = { instancePath: t + "/umdNamedDefine", schemaPath: "#/definitions/UmdNamedDefine/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                                            null === r ? r = [e] : r.push(e), i++;
                                                                        }
                                                                        if (m === i && (n = !0, l = 0), !n) {
                                                                            const e = { instancePath: t + "/umdNamedDefine", schemaPath: "#/properties/umdNamedDefine/oneOf", keyword: "oneOf", params: { passingSchemas: l }, message: "must match exactly one schema in oneOf" };
                                                                            return null === r ? r = [e] : r.push(e), i++, G.errors = r, !1;
                                                                        }
                                                                        i = s, null !== r && (s ? r.length = s : r = null), o = a === i;
                                                                    }
                                                                    else
                                                                        o = !0;
                                                                    if (o)
                                                                        if (void 0 !== e.uniqueName) {
                                                                            let a = e.uniqueName;
                                                                            const s = i;
                                                                            if (i == i) {
                                                                                if ("string" != typeof a)
                                                                                    return G.errors = [{ instancePath: t + "/uniqueName", schemaPath: "#/definitions/UniqueName/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                                                if (a.length < 1)
                                                                                    return G.errors = [{ instancePath: t + "/uniqueName", schemaPath: "#/definitions/UniqueName/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' }], !1;
                                                                            }
                                                                            o = s === i;
                                                                        }
                                                                        else
                                                                            o = !0;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
} return G.errors = r, 0 === i; }
function U(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; if (0 === i) {
    if (!Array.isArray(e))
        return U.errors = [{ instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
    {
        const a = e.length;
        for (let s = 0; s < a; s++) {
            let a = e[s];
            const n = i, l = i;
            let m = !1;
            const p = i;
            if (i == i)
                if (a && "object" == typeof a && !Array.isArray(a)) {
                    let e;
                    if (void 0 === a.apply && (e = "apply")) {
                        const a = { instancePath: t + "/" + s, schemaPath: "#/definitions/RspackPluginInstance/required", keyword: "required", params: { missingProperty: e }, message: "must have required property '" + e + "'" };
                        null === r ? r = [a] : r.push(a), i++;
                    }
                    else if (void 0 !== a.apply && !(a.apply instanceof Function)) {
                        const e = { instancePath: t + "/" + s + "/apply", schemaPath: "#/definitions/RspackPluginInstance/properties/apply/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                }
                else {
                    const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/RspackPluginInstance/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                    null === r ? r = [e] : r.push(e), i++;
                }
            var o = p === i;
            if (m = m || o, !m) {
                const e = i;
                if (!(a instanceof Function)) {
                    const e = { instancePath: t + "/" + s, schemaPath: "#/definitions/RspackPluginFunction/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                    null === r ? r = [e] : r.push(e), i++;
                }
                o = e === i, m = m || o;
            }
            if (!m) {
                const e = { instancePath: t + "/" + s, schemaPath: "#/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                return null === r ? r = [e] : r.push(e), i++, U.errors = r, !1;
            }
            if (i = l, null !== r && (l ? r.length = l : r = null), n !== i)
                break;
        }
    }
} return U.errors = r, 0 === i; }
function M(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1, m = null; const p = i; if (g(e, { instancePath: t, parentData: a, parentDataProperty: s, rootData: n }) || (r = null === r ? g.errors : r.concat(g.errors), i = r.length), p === i && (l = !0, m = 0), !l) {
    const e = { instancePath: t, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: m }, message: "must match exactly one schema in oneOf" };
    return null === r ? r = [e] : r.push(e), i++, M.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), M.errors = r, 0 === i; }
function W(e, { instancePath: t = "", parentData: a, parentDataProperty: s, rootData: n = e } = {}) { let r = null, i = 0; const o = i; let l = !1; const m = i; if ("none" !== e && "errors-only" !== e && "errors-warnings" !== e && "normal" !== e && "verbose" !== e) {
    const e = { instancePath: t, schemaPath: "#/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
    null === r ? r = [e] : r.push(e), i++;
} var p = m === i; if (l = l || p, !l) {
    const a = i;
    if ("boolean" != typeof e) {
        const e = { instancePath: t, schemaPath: "#/anyOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
        null === r ? r = [e] : r.push(e), i++;
    }
    if (p = a === i, l = l || p, !l) {
        const a = i;
        if (i == i)
            if (e && "object" == typeof e && !Array.isArray(e)) {
                if (void 0 !== e.all) {
                    const a = i;
                    if ("boolean" != typeof e.all) {
                        const e = { instancePath: t + "/all", schemaPath: "#/definitions/StatsOptions/properties/all/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                        null === r ? r = [e] : r.push(e), i++;
                    }
                    var c = a === i;
                }
                else
                    c = !0;
                if (c) {
                    if (void 0 !== e.assets) {
                        const a = i;
                        if ("boolean" != typeof e.assets) {
                            const e = { instancePath: t + "/assets", schemaPath: "#/definitions/StatsOptions/properties/assets/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                            null === r ? r = [e] : r.push(e), i++;
                        }
                        c = a === i;
                    }
                    else
                        c = !0;
                    if (c) {
                        if (void 0 !== e.chunkGroups) {
                            const a = i;
                            if ("boolean" != typeof e.chunkGroups) {
                                const e = { instancePath: t + "/chunkGroups", schemaPath: "#/definitions/StatsOptions/properties/chunkGroups/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                null === r ? r = [e] : r.push(e), i++;
                            }
                            c = a === i;
                        }
                        else
                            c = !0;
                        if (c) {
                            if (void 0 !== e.chunks) {
                                const a = i;
                                if ("boolean" != typeof e.chunks) {
                                    const e = { instancePath: t + "/chunks", schemaPath: "#/definitions/StatsOptions/properties/chunks/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                    null === r ? r = [e] : r.push(e), i++;
                                }
                                c = a === i;
                            }
                            else
                                c = !0;
                            if (c) {
                                if (void 0 !== e.colors) {
                                    const a = i;
                                    if ("boolean" != typeof e.colors) {
                                        const e = { instancePath: t + "/colors", schemaPath: "#/definitions/StatsOptions/properties/colors/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                        null === r ? r = [e] : r.push(e), i++;
                                    }
                                    c = a === i;
                                }
                                else
                                    c = !0;
                                if (c) {
                                    if (void 0 !== e.entrypoints) {
                                        let a = e.entrypoints;
                                        const s = i, n = i;
                                        let o = !1;
                                        const l = i;
                                        if ("auto" !== a) {
                                            const e = { instancePath: t + "/entrypoints", schemaPath: "#/definitions/StatsOptions/properties/entrypoints/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                        var h = l === i;
                                        if (o = o || h, !o) {
                                            const e = i;
                                            if ("boolean" != typeof a) {
                                                const e = { instancePath: t + "/entrypoints", schemaPath: "#/definitions/StatsOptions/properties/entrypoints/anyOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                null === r ? r = [e] : r.push(e), i++;
                                            }
                                            h = e === i, o = o || h;
                                        }
                                        if (o)
                                            i = n, null !== r && (n ? r.length = n : r = null);
                                        else {
                                            const e = { instancePath: t + "/entrypoints", schemaPath: "#/definitions/StatsOptions/properties/entrypoints/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                            null === r ? r = [e] : r.push(e), i++;
                                        }
                                        c = s === i;
                                    }
                                    else
                                        c = !0;
                                    if (c) {
                                        if (void 0 !== e.errors) {
                                            const a = i;
                                            if ("boolean" != typeof e.errors) {
                                                const e = { instancePath: t + "/errors", schemaPath: "#/definitions/StatsOptions/properties/errors/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                null === r ? r = [e] : r.push(e), i++;
                                            }
                                            c = a === i;
                                        }
                                        else
                                            c = !0;
                                        if (c) {
                                            if (void 0 !== e.errorsCount) {
                                                const a = i;
                                                if ("boolean" != typeof e.errorsCount) {
                                                    const e = { instancePath: t + "/errorsCount", schemaPath: "#/definitions/StatsOptions/properties/errorsCount/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                    null === r ? r = [e] : r.push(e), i++;
                                                }
                                                c = a === i;
                                            }
                                            else
                                                c = !0;
                                            if (c) {
                                                if (void 0 !== e.hash) {
                                                    const a = i;
                                                    if ("boolean" != typeof e.hash) {
                                                        const e = { instancePath: t + "/hash", schemaPath: "#/definitions/StatsOptions/properties/hash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                        null === r ? r = [e] : r.push(e), i++;
                                                    }
                                                    c = a === i;
                                                }
                                                else
                                                    c = !0;
                                                if (c) {
                                                    if (void 0 !== e.modules) {
                                                        const a = i;
                                                        if ("boolean" != typeof e.modules) {
                                                            const e = { instancePath: t + "/modules", schemaPath: "#/definitions/StatsOptions/properties/modules/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                            null === r ? r = [e] : r.push(e), i++;
                                                        }
                                                        c = a === i;
                                                    }
                                                    else
                                                        c = !0;
                                                    if (c) {
                                                        if (void 0 !== e.preset) {
                                                            let a = e.preset;
                                                            const s = i, n = i;
                                                            let o = !1;
                                                            const l = i;
                                                            if ("boolean" != typeof a) {
                                                                const e = { instancePath: t + "/preset", schemaPath: "#/definitions/StatsOptions/properties/preset/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                                null === r ? r = [e] : r.push(e), i++;
                                                            }
                                                            var u = l === i;
                                                            if (o = o || u, !o) {
                                                                const e = i;
                                                                if ("string" != typeof a) {
                                                                    const e = { instancePath: t + "/preset", schemaPath: "#/definitions/StatsOptions/properties/preset/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                    null === r ? r = [e] : r.push(e), i++;
                                                                }
                                                                u = e === i, o = o || u;
                                                            }
                                                            if (o)
                                                                i = n, null !== r && (n ? r.length = n : r = null);
                                                            else {
                                                                const e = { instancePath: t + "/preset", schemaPath: "#/definitions/StatsOptions/properties/preset/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                null === r ? r = [e] : r.push(e), i++;
                                                            }
                                                            c = s === i;
                                                        }
                                                        else
                                                            c = !0;
                                                        if (c) {
                                                            if (void 0 !== e.publicPath) {
                                                                const a = i;
                                                                if ("boolean" != typeof e.publicPath) {
                                                                    const e = { instancePath: t + "/publicPath", schemaPath: "#/definitions/StatsOptions/properties/publicPath/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                                    null === r ? r = [e] : r.push(e), i++;
                                                                }
                                                                c = a === i;
                                                            }
                                                            else
                                                                c = !0;
                                                            if (c) {
                                                                if (void 0 !== e.reasons) {
                                                                    const a = i;
                                                                    if ("boolean" != typeof e.reasons) {
                                                                        const e = { instancePath: t + "/reasons", schemaPath: "#/definitions/StatsOptions/properties/reasons/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                                        null === r ? r = [e] : r.push(e), i++;
                                                                    }
                                                                    c = a === i;
                                                                }
                                                                else
                                                                    c = !0;
                                                                if (c) {
                                                                    if (void 0 !== e.warnings) {
                                                                        const a = i;
                                                                        if ("boolean" != typeof e.warnings) {
                                                                            const e = { instancePath: t + "/warnings", schemaPath: "#/definitions/StatsOptions/properties/warnings/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                                            null === r ? r = [e] : r.push(e), i++;
                                                                        }
                                                                        c = a === i;
                                                                    }
                                                                    else
                                                                        c = !0;
                                                                    if (c)
                                                                        if (void 0 !== e.warningsCount) {
                                                                            const a = i;
                                                                            if ("boolean" != typeof e.warningsCount) {
                                                                                const e = { instancePath: t + "/warningsCount", schemaPath: "#/definitions/StatsOptions/properties/warningsCount/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                                                null === r ? r = [e] : r.push(e), i++;
                                                                            }
                                                                            c = a === i;
                                                                        }
                                                                        else
                                                                            c = !0;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else {
                const e = { instancePath: t, schemaPath: "#/definitions/StatsOptions/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                null === r ? r = [e] : r.push(e), i++;
            }
        p = a === i, l = l || p;
    }
} if (!l) {
    const e = { instancePath: t, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    return null === r ? r = [e] : r.push(e), i++, W.errors = r, !1;
} return i = o, null !== r && (o ? r.length = o : r = null), W.errors = r, 0 === i; }
function $(t, { instancePath: a = "", parentData: s, parentDataProperty: n, rootData: i = t } = {}) { let l = null, p = 0; if (0 === p) {
    if (!t || "object" != typeof t || Array.isArray(t))
        return $.errors = [{ instancePath: a, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
    if (void 0 !== t.cache) {
        const e = p;
        if ("boolean" != typeof t.cache)
            return $.errors = [{ instancePath: a + "/cache", schemaPath: "#/definitions/CacheOptions/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
        var c = e === p;
    }
    else
        c = !0;
    if (c) {
        if (void 0 !== t.context) {
            const e = p;
            if ("string" != typeof t.context)
                return $.errors = [{ instancePath: a + "/context", schemaPath: "#/definitions/Context/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
            c = e === p;
        }
        else
            c = !0;
        if (c) {
            if (void 0 !== t.dependencies) {
                let e = t.dependencies;
                const s = p;
                if (p == p) {
                    if (!Array.isArray(e))
                        return $.errors = [{ instancePath: a + "/dependencies", schemaPath: "#/definitions/Dependencies/type", keyword: "type", params: { type: "array" }, message: "must be array" }], !1;
                    {
                        const t = e.length;
                        for (let s = 0; s < t; s++) {
                            const t = p;
                            if ("string" != typeof e[s])
                                return $.errors = [{ instancePath: a + "/dependencies/" + s, schemaPath: "#/definitions/Dependencies/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                            if (t !== p)
                                break;
                        }
                    }
                }
                c = s === p;
            }
            else
                c = !0;
            if (c) {
                if (void 0 !== t.devServer) {
                    let e = t.devServer;
                    const s = p;
                    if (!e || "object" != typeof e || Array.isArray(e))
                        return $.errors = [{ instancePath: a + "/devServer", schemaPath: "#/definitions/DevServer/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                    c = s === p;
                }
                else
                    c = !0;
                if (c) {
                    if (void 0 !== t.devtool) {
                        let s = t.devtool;
                        const n = p, r = p;
                        let i = !1;
                        const o = p;
                        if (!1 !== s) {
                            const e = { instancePath: a + "/devtool", schemaPath: "#/definitions/DevTool/anyOf/0/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                            null === l ? l = [e] : l.push(e), p++;
                        }
                        var h = o === p;
                        if (i = i || h, !i) {
                            const t = p;
                            if (p === t)
                                if ("string" == typeof s) {
                                    if (!e.test(s)) {
                                        const e = { instancePath: a + "/devtool", schemaPath: "#/definitions/DevTool/anyOf/1/pattern", keyword: "pattern", params: { pattern: "^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$" }, message: 'must match pattern "^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$"' };
                                        null === l ? l = [e] : l.push(e), p++;
                                    }
                                }
                                else {
                                    const e = { instancePath: a + "/devtool", schemaPath: "#/definitions/DevTool/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    null === l ? l = [e] : l.push(e), p++;
                                }
                            h = t === p, i = i || h;
                        }
                        if (!i) {
                            const e = { instancePath: a + "/devtool", schemaPath: "#/definitions/DevTool/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                            return null === l ? l = [e] : l.push(e), p++, $.errors = l, !1;
                        }
                        p = r, null !== l && (r ? l.length = r : l = null), c = n === p;
                    }
                    else
                        c = !0;
                    if (c) {
                        if (void 0 !== t.entry) {
                            const e = p;
                            r(t.entry, { instancePath: a + "/entry", parentData: t, parentDataProperty: "entry", rootData: i }) || (l = null === l ? r.errors : l.concat(r.errors), p = l.length), c = e === p;
                        }
                        else
                            c = !0;
                        if (c) {
                            if (void 0 !== t.experiments) {
                                let e = t.experiments;
                                const s = p;
                                if (p == p) {
                                    if (!e || "object" != typeof e || Array.isArray(e))
                                        return $.errors = [{ instancePath: a + "/experiments", schemaPath: "#/definitions/Experiments/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                    {
                                        const t = p;
                                        for (const t in e)
                                            if ("incrementalRebuild" !== t && "lazyCompilation" !== t)
                                                return $.errors = [{ instancePath: a + "/experiments", schemaPath: "#/definitions/Experiments/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: t }, message: "must NOT have additional properties" }], !1;
                                        if (t === p) {
                                            if (void 0 !== e.incrementalRebuild) {
                                                const t = p;
                                                if ("boolean" != typeof e.incrementalRebuild)
                                                    return $.errors = [{ instancePath: a + "/experiments/incrementalRebuild", schemaPath: "#/definitions/Experiments/properties/incrementalRebuild/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                var u = t === p;
                                            }
                                            else
                                                u = !0;
                                            if (u)
                                                if (void 0 !== e.lazyCompilation) {
                                                    const t = p, s = p;
                                                    let n = !1;
                                                    const r = p;
                                                    if ("boolean" != typeof e.lazyCompilation) {
                                                        const e = { instancePath: a + "/experiments/lazyCompilation", schemaPath: "#/definitions/Experiments/properties/lazyCompilation/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                        null === l ? l = [e] : l.push(e), p++;
                                                    }
                                                    if (n = n || r === p, !n) {
                                                        const e = { instancePath: a + "/experiments/lazyCompilation", schemaPath: "#/definitions/Experiments/properties/lazyCompilation/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                        return null === l ? l = [e] : l.push(e), p++, $.errors = l, !1;
                                                    }
                                                    p = s, null !== l && (s ? l.length = s : l = null), u = t === p;
                                                }
                                                else
                                                    u = !0;
                                        }
                                    }
                                }
                                c = s === p;
                            }
                            else
                                c = !0;
                            if (c) {
                                if (void 0 !== t.externals) {
                                    const e = p;
                                    o(t.externals, { instancePath: a + "/externals", parentData: t, parentDataProperty: "externals", rootData: i }) || (l = null === l ? o.errors : l.concat(o.errors), p = l.length), c = e === p;
                                }
                                else
                                    c = !0;
                                if (c) {
                                    if (void 0 !== t.externalsType) {
                                        let e = t.externalsType;
                                        const s = p;
                                        if ("var" !== e && "module" !== e && "assign" !== e && "this" !== e && "window" !== e && "self" !== e && "global" !== e && "commonjs" !== e && "commonjs2" !== e && "commonjs-module" !== e && "commonjs-static" !== e && "amd" !== e && "amd-require" !== e && "umd" !== e && "umd2" !== e && "jsonp" !== e && "system" !== e && "promise" !== e && "import" !== e && "script" !== e && "node-commonjs" !== e)
                                            return $.errors = [{ instancePath: a + "/externalsType", schemaPath: "#/definitions/ExternalsType/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' }], !1;
                                        c = s === p;
                                    }
                                    else
                                        c = !0;
                                    if (c) {
                                        if (void 0 !== t.infrastructureLogging) {
                                            const e = p;
                                            m(t.infrastructureLogging, { instancePath: a + "/infrastructureLogging", parentData: t, parentDataProperty: "infrastructureLogging", rootData: i }) || (l = null === l ? m.errors : l.concat(m.errors), p = l.length), c = e === p;
                                        }
                                        else
                                            c = !0;
                                        if (c) {
                                            if (void 0 !== t.mode) {
                                                let e = t.mode;
                                                const s = p;
                                                if ("development" !== e && "production" !== e && "none" !== e)
                                                    return $.errors = [{ instancePath: a + "/mode", schemaPath: "#/definitions/Mode/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' }], !1;
                                                c = s === p;
                                            }
                                            else
                                                c = !0;
                                            if (c) {
                                                if (void 0 !== t.module) {
                                                    const e = p;
                                                    j(t.module, { instancePath: a + "/module", parentData: t, parentDataProperty: "module", rootData: i }) || (l = null === l ? j.errors : l.concat(j.errors), p = l.length), c = e === p;
                                                }
                                                else
                                                    c = !0;
                                                if (c) {
                                                    if (void 0 !== t.name) {
                                                        const e = p;
                                                        if ("string" != typeof t.name)
                                                            return $.errors = [{ instancePath: a + "/name", schemaPath: "#/definitions/Name/type", keyword: "type", params: { type: "string" }, message: "must be string" }], !1;
                                                        c = e === p;
                                                    }
                                                    else
                                                        c = !0;
                                                    if (c) {
                                                        if (void 0 !== t.node) {
                                                            const e = p;
                                                            A(t.node, { instancePath: a + "/node", parentData: t, parentDataProperty: "node", rootData: i }) || (l = null === l ? A.errors : l.concat(A.errors), p = l.length), c = e === p;
                                                        }
                                                        else
                                                            c = !0;
                                                        if (c) {
                                                            if (void 0 !== t.optimization) {
                                                                const e = p;
                                                                C(t.optimization, { instancePath: a + "/optimization", parentData: t, parentDataProperty: "optimization", rootData: i }) || (l = null === l ? C.errors : l.concat(C.errors), p = l.length), c = e === p;
                                                            }
                                                            else
                                                                c = !0;
                                                            if (c) {
                                                                if (void 0 !== t.output) {
                                                                    const e = p;
                                                                    G(t.output, { instancePath: a + "/output", parentData: t, parentDataProperty: "output", rootData: i }) || (l = null === l ? G.errors : l.concat(G.errors), p = l.length), c = e === p;
                                                                }
                                                                else
                                                                    c = !0;
                                                                if (c) {
                                                                    if (void 0 !== t.plugins) {
                                                                        const e = p;
                                                                        U(t.plugins, { instancePath: a + "/plugins", parentData: t, parentDataProperty: "plugins", rootData: i }) || (l = null === l ? U.errors : l.concat(U.errors), p = l.length), c = e === p;
                                                                    }
                                                                    else
                                                                        c = !0;
                                                                    if (c) {
                                                                        if (void 0 !== t.resolve) {
                                                                            const e = p;
                                                                            M(t.resolve, { instancePath: a + "/resolve", parentData: t, parentDataProperty: "resolve", rootData: i }) || (l = null === l ? M.errors : l.concat(M.errors), p = l.length), c = e === p;
                                                                        }
                                                                        else
                                                                            c = !0;
                                                                        if (c) {
                                                                            if (void 0 !== t.snapshot) {
                                                                                let e = t.snapshot;
                                                                                const s = p;
                                                                                if (p == p) {
                                                                                    if (!e || "object" != typeof e || Array.isArray(e))
                                                                                        return $.errors = [{ instancePath: a + "/snapshot", schemaPath: "#/definitions/SnapshotOptions/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                                    {
                                                                                        const t = p;
                                                                                        for (const t in e)
                                                                                            if ("module" !== t && "resolve" !== t)
                                                                                                return $.errors = [{ instancePath: a + "/snapshot", schemaPath: "#/definitions/SnapshotOptions/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: t }, message: "must NOT have additional properties" }], !1;
                                                                                        if (t === p) {
                                                                                            if (void 0 !== e.module) {
                                                                                                let t = e.module;
                                                                                                const s = p;
                                                                                                if (p === s) {
                                                                                                    if (!t || "object" != typeof t || Array.isArray(t))
                                                                                                        return $.errors = [{ instancePath: a + "/snapshot/module", schemaPath: "#/definitions/SnapshotOptions/properties/module/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                                                    {
                                                                                                        const e = p;
                                                                                                        for (const e in t)
                                                                                                            if ("hash" !== e && "timestamp" !== e)
                                                                                                                return $.errors = [{ instancePath: a + "/snapshot/module", schemaPath: "#/definitions/SnapshotOptions/properties/module/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: e }, message: "must NOT have additional properties" }], !1;
                                                                                                        if (e === p) {
                                                                                                            if (void 0 !== t.hash) {
                                                                                                                const e = p;
                                                                                                                if ("boolean" != typeof t.hash)
                                                                                                                    return $.errors = [{ instancePath: a + "/snapshot/module/hash", schemaPath: "#/definitions/SnapshotOptions/properties/module/properties/hash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                                                                                var y = e === p;
                                                                                                            }
                                                                                                            else
                                                                                                                y = !0;
                                                                                                            if (y)
                                                                                                                if (void 0 !== t.timestamp) {
                                                                                                                    const e = p;
                                                                                                                    if ("boolean" != typeof t.timestamp)
                                                                                                                        return $.errors = [{ instancePath: a + "/snapshot/module/timestamp", schemaPath: "#/definitions/SnapshotOptions/properties/module/properties/timestamp/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                                                                                    y = e === p;
                                                                                                                }
                                                                                                                else
                                                                                                                    y = !0;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                var f = s === p;
                                                                                            }
                                                                                            else
                                                                                                f = !0;
                                                                                            if (f)
                                                                                                if (void 0 !== e.resolve) {
                                                                                                    let t = e.resolve;
                                                                                                    const s = p;
                                                                                                    if (p === s) {
                                                                                                        if (!t || "object" != typeof t || Array.isArray(t))
                                                                                                            return $.errors = [{ instancePath: a + "/snapshot/resolve", schemaPath: "#/definitions/SnapshotOptions/properties/resolve/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                                                        {
                                                                                                            const e = p;
                                                                                                            for (const e in t)
                                                                                                                if ("hash" !== e && "timestamp" !== e)
                                                                                                                    return $.errors = [{ instancePath: a + "/snapshot/resolve", schemaPath: "#/definitions/SnapshotOptions/properties/resolve/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: e }, message: "must NOT have additional properties" }], !1;
                                                                                                            if (e === p) {
                                                                                                                if (void 0 !== t.hash) {
                                                                                                                    const e = p;
                                                                                                                    if ("boolean" != typeof t.hash)
                                                                                                                        return $.errors = [{ instancePath: a + "/snapshot/resolve/hash", schemaPath: "#/definitions/SnapshotOptions/properties/resolve/properties/hash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                                                                                    var d = e === p;
                                                                                                                }
                                                                                                                else
                                                                                                                    d = !0;
                                                                                                                if (d)
                                                                                                                    if (void 0 !== t.timestamp) {
                                                                                                                        const e = p;
                                                                                                                        if ("boolean" != typeof t.timestamp)
                                                                                                                            return $.errors = [{ instancePath: a + "/snapshot/resolve/timestamp", schemaPath: "#/definitions/SnapshotOptions/properties/resolve/properties/timestamp/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                                                                                        d = e === p;
                                                                                                                    }
                                                                                                                    else
                                                                                                                        d = !0;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    f = s === p;
                                                                                                }
                                                                                                else
                                                                                                    f = !0;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                c = s === p;
                                                                            }
                                                                            else
                                                                                c = !0;
                                                                            if (c) {
                                                                                if (void 0 !== t.stats) {
                                                                                    const e = p;
                                                                                    W(t.stats, { instancePath: a + "/stats", parentData: t, parentDataProperty: "stats", rootData: i }) || (l = null === l ? W.errors : l.concat(W.errors), p = l.length), c = e === p;
                                                                                }
                                                                                else
                                                                                    c = !0;
                                                                                if (c) {
                                                                                    if (void 0 !== t.target) {
                                                                                        let e = t.target;
                                                                                        const s = p, n = p;
                                                                                        let r = !1;
                                                                                        const i = p;
                                                                                        if (p === i)
                                                                                            if (Array.isArray(e))
                                                                                                if (e.length < 1) {
                                                                                                    const e = { instancePath: a + "/target", schemaPath: "#/definitions/Target/anyOf/0/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                                    null === l ? l = [e] : l.push(e), p++;
                                                                                                }
                                                                                                else {
                                                                                                    const t = e.length;
                                                                                                    for (let s = 0; s < t; s++) {
                                                                                                        let t = e[s];
                                                                                                        const n = p;
                                                                                                        if (p === n)
                                                                                                            if ("string" == typeof t) {
                                                                                                                if (t.length < 1) {
                                                                                                                    const e = { instancePath: a + "/target/" + s, schemaPath: "#/definitions/Target/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                                                                                    null === l ? l = [e] : l.push(e), p++;
                                                                                                                }
                                                                                                            }
                                                                                                            else {
                                                                                                                const e = { instancePath: a + "/target/" + s, schemaPath: "#/definitions/Target/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                                                null === l ? l = [e] : l.push(e), p++;
                                                                                                            }
                                                                                                        if (n !== p)
                                                                                                            break;
                                                                                                    }
                                                                                                }
                                                                                            else {
                                                                                                const e = { instancePath: a + "/target", schemaPath: "#/definitions/Target/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                                null === l ? l = [e] : l.push(e), p++;
                                                                                            }
                                                                                        var g = i === p;
                                                                                        if (r = r || g, !r) {
                                                                                            const t = p;
                                                                                            if (!1 !== e) {
                                                                                                const e = { instancePath: a + "/target", schemaPath: "#/definitions/Target/anyOf/1/enum", keyword: "enum", params: {}, message: 'must pass "enum" keyword validation' };
                                                                                                null === l ? l = [e] : l.push(e), p++;
                                                                                            }
                                                                                            if (g = t === p, r = r || g, !r) {
                                                                                                const t = p;
                                                                                                if (p === t)
                                                                                                    if ("string" == typeof e) {
                                                                                                        if (e.length < 1) {
                                                                                                            const e = { instancePath: a + "/target", schemaPath: "#/definitions/Target/anyOf/2/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                                                                            null === l ? l = [e] : l.push(e), p++;
                                                                                                        }
                                                                                                    }
                                                                                                    else {
                                                                                                        const e = { instancePath: a + "/target", schemaPath: "#/definitions/Target/anyOf/2/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                                        null === l ? l = [e] : l.push(e), p++;
                                                                                                    }
                                                                                                g = t === p, r = r || g;
                                                                                            }
                                                                                        }
                                                                                        if (!r) {
                                                                                            const e = { instancePath: a + "/target", schemaPath: "#/definitions/Target/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                                            return null === l ? l = [e] : l.push(e), p++, $.errors = l, !1;
                                                                                        }
                                                                                        p = n, null !== l && (n ? l.length = n : l = null), c = s === p;
                                                                                    }
                                                                                    else
                                                                                        c = !0;
                                                                                    if (c) {
                                                                                        if (void 0 !== t.watch) {
                                                                                            const e = p;
                                                                                            if ("boolean" != typeof t.watch)
                                                                                                return $.errors = [{ instancePath: a + "/watch", schemaPath: "#/definitions/Watch/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                                                            c = e === p;
                                                                                        }
                                                                                        else
                                                                                            c = !0;
                                                                                        if (c) {
                                                                                            if (void 0 !== t.watchOptions) {
                                                                                                let e = t.watchOptions;
                                                                                                const s = p;
                                                                                                if (p == p) {
                                                                                                    if (!e || "object" != typeof e || Array.isArray(e))
                                                                                                        return $.errors = [{ instancePath: a + "/watchOptions", schemaPath: "#/definitions/WatchOptions/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                                                    {
                                                                                                        const t = p;
                                                                                                        for (const t in e)
                                                                                                            if ("aggregateTimeout" !== t && "followSymlinks" !== t && "ignored" !== t && "poll" !== t && "stdin" !== t)
                                                                                                                return $.errors = [{ instancePath: a + "/watchOptions", schemaPath: "#/definitions/WatchOptions/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: t }, message: "must NOT have additional properties" }], !1;
                                                                                                        if (t === p) {
                                                                                                            if (void 0 !== e.aggregateTimeout) {
                                                                                                                const t = p;
                                                                                                                if ("number" != typeof e.aggregateTimeout)
                                                                                                                    return $.errors = [{ instancePath: a + "/watchOptions/aggregateTimeout", schemaPath: "#/definitions/WatchOptions/properties/aggregateTimeout/type", keyword: "type", params: { type: "number" }, message: "must be number" }], !1;
                                                                                                                var P = t === p;
                                                                                                            }
                                                                                                            else
                                                                                                                P = !0;
                                                                                                            if (P) {
                                                                                                                if (void 0 !== e.followSymlinks) {
                                                                                                                    const t = p;
                                                                                                                    if ("boolean" != typeof e.followSymlinks)
                                                                                                                        return $.errors = [{ instancePath: a + "/watchOptions/followSymlinks", schemaPath: "#/definitions/WatchOptions/properties/followSymlinks/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                                                                                    P = t === p;
                                                                                                                }
                                                                                                                else
                                                                                                                    P = !0;
                                                                                                                if (P) {
                                                                                                                    if (void 0 !== e.ignored) {
                                                                                                                        let t = e.ignored;
                                                                                                                        const s = p, n = p;
                                                                                                                        let r = !1;
                                                                                                                        const i = p;
                                                                                                                        if (p === i)
                                                                                                                            if (Array.isArray(t)) {
                                                                                                                                const e = t.length;
                                                                                                                                for (let s = 0; s < e; s++) {
                                                                                                                                    let e = t[s];
                                                                                                                                    const n = p;
                                                                                                                                    if (p === n)
                                                                                                                                        if ("string" == typeof e) {
                                                                                                                                            if (e.length < 1) {
                                                                                                                                                const e = { instancePath: a + "/watchOptions/ignored/" + s, schemaPath: "#/definitions/WatchOptions/properties/ignored/anyOf/0/items/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                                                                                                                null === l ? l = [e] : l.push(e), p++;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        else {
                                                                                                                                            const e = { instancePath: a + "/watchOptions/ignored/" + s, schemaPath: "#/definitions/WatchOptions/properties/ignored/anyOf/0/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                                                                            null === l ? l = [e] : l.push(e), p++;
                                                                                                                                        }
                                                                                                                                    if (n !== p)
                                                                                                                                        break;
                                                                                                                                }
                                                                                                                            }
                                                                                                                            else {
                                                                                                                                const e = { instancePath: a + "/watchOptions/ignored", schemaPath: "#/definitions/WatchOptions/properties/ignored/anyOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                                                                null === l ? l = [e] : l.push(e), p++;
                                                                                                                            }
                                                                                                                        var b = i === p;
                                                                                                                        if (r = r || b, !r) {
                                                                                                                            const e = p;
                                                                                                                            if (!(t instanceof RegExp)) {
                                                                                                                                const e = { instancePath: a + "/watchOptions/ignored", schemaPath: "#/definitions/WatchOptions/properties/ignored/anyOf/1/instanceof", keyword: "instanceof", params: {}, message: 'must pass "instanceof" keyword validation' };
                                                                                                                                null === l ? l = [e] : l.push(e), p++;
                                                                                                                            }
                                                                                                                            if (b = e === p, r = r || b, !r) {
                                                                                                                                const e = p;
                                                                                                                                if (p === e)
                                                                                                                                    if ("string" == typeof t) {
                                                                                                                                        if (t.length < 1) {
                                                                                                                                            const e = { instancePath: a + "/watchOptions/ignored", schemaPath: "#/definitions/WatchOptions/properties/ignored/anyOf/2/minLength", keyword: "minLength", params: {}, message: 'must pass "minLength" keyword validation' };
                                                                                                                                            null === l ? l = [e] : l.push(e), p++;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    else {
                                                                                                                                        const e = { instancePath: a + "/watchOptions/ignored", schemaPath: "#/definitions/WatchOptions/properties/ignored/anyOf/2/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                                                                        null === l ? l = [e] : l.push(e), p++;
                                                                                                                                    }
                                                                                                                                b = e === p, r = r || b;
                                                                                                                            }
                                                                                                                        }
                                                                                                                        if (!r) {
                                                                                                                            const e = { instancePath: a + "/watchOptions/ignored", schemaPath: "#/definitions/WatchOptions/properties/ignored/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                                                                            return null === l ? l = [e] : l.push(e), p++, $.errors = l, !1;
                                                                                                                        }
                                                                                                                        p = n, null !== l && (n ? l.length = n : l = null), P = s === p;
                                                                                                                    }
                                                                                                                    else
                                                                                                                        P = !0;
                                                                                                                    if (P) {
                                                                                                                        if (void 0 !== e.poll) {
                                                                                                                            let t = e.poll;
                                                                                                                            const s = p, n = p;
                                                                                                                            let r = !1;
                                                                                                                            const i = p;
                                                                                                                            if ("number" != typeof t) {
                                                                                                                                const e = { instancePath: a + "/watchOptions/poll", schemaPath: "#/definitions/WatchOptions/properties/poll/anyOf/0/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                                                                                                                                null === l ? l = [e] : l.push(e), p++;
                                                                                                                            }
                                                                                                                            var O = i === p;
                                                                                                                            if (r = r || O, !r) {
                                                                                                                                const e = p;
                                                                                                                                if ("boolean" != typeof t) {
                                                                                                                                    const e = { instancePath: a + "/watchOptions/poll", schemaPath: "#/definitions/WatchOptions/properties/poll/anyOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                                                                                                    null === l ? l = [e] : l.push(e), p++;
                                                                                                                                }
                                                                                                                                O = e === p, r = r || O;
                                                                                                                            }
                                                                                                                            if (!r) {
                                                                                                                                const e = { instancePath: a + "/watchOptions/poll", schemaPath: "#/definitions/WatchOptions/properties/poll/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                                                                                return null === l ? l = [e] : l.push(e), p++, $.errors = l, !1;
                                                                                                                            }
                                                                                                                            p = n, null !== l && (n ? l.length = n : l = null), P = s === p;
                                                                                                                        }
                                                                                                                        else
                                                                                                                            P = !0;
                                                                                                                        if (P)
                                                                                                                            if (void 0 !== e.stdin) {
                                                                                                                                const t = p;
                                                                                                                                if ("boolean" != typeof e.stdin)
                                                                                                                                    return $.errors = [{ instancePath: a + "/watchOptions/stdin", schemaPath: "#/definitions/WatchOptions/properties/stdin/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }], !1;
                                                                                                                                P = t === p;
                                                                                                                            }
                                                                                                                            else
                                                                                                                                P = !0;
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                c = s === p;
                                                                                            }
                                                                                            else
                                                                                                c = !0;
                                                                                            if (c)
                                                                                                if (void 0 !== t.builtins) {
                                                                                                    let e = t.builtins;
                                                                                                    const s = p;
                                                                                                    if (p === s && (!e || "object" != typeof e || Array.isArray(e)))
                                                                                                        return $.errors = [{ instancePath: a + "/builtins", schemaPath: "#/properties/builtins/type", keyword: "type", params: { type: "object" }, message: "must be object" }], !1;
                                                                                                    c = s === p;
                                                                                                }
                                                                                                else
                                                                                                    c = !0;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
} return $.errors = l, 0 === p; }
//# sourceMappingURL=schema.check.js.map